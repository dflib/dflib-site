<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Andrus Adamchik and other contributors">
<title>DFLib DataFrame Documentation - v2 (alpha)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/*! Stylesheet for CodeRay to loosely match GitHub themes | MIT License */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid;opacity:.35;padding:0 .5em 0 0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff!important;background:navy!important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:navy}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:teal}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:teal}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:teal}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword{color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:teal}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<meta name="description" content="Documentation for DFLib Java DataFrame library version 2. Provides a guide on how to create DataFrames from different data sources and how to use DataFrames for a variety of data transformation operations.">
<link rel="canonical" href="/dflib/docs/2.x/">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>DFLib DataFrame Documentation - v2 (alpha)</h1>
<div class="details">
<span id="author" class="author">Andrus Adamchik and other contributors</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_get_started_with_dflib">Get Started with DFLib</a></li>
<li><a href="#_main_data_structures">Main Data Structures</a>
<ul class="sectlevel2">
<li><a href="#_series">Series</a></li>
<li><a href="#_dataframe">DataFrame</a></li>
<li><a href="#index">Index</a></li>
</ul>
</li>
<li><a href="#printers">Printers</a></li>
<li><a href="#expressions">Expressions</a>
<ul class="sectlevel2">
<li><a href="#_column_expressions">Column Expressions</a></li>
<li><a href="#_constant_expressions">Constant Expressions</a></li>
<li><a href="#_string_expressions">String Expressions</a></li>
<li><a href="#_numeric_expressions">Numeric Expressions</a></li>
<li><a href="#_date_expressions">Date Expressions</a></li>
<li><a href="#_complex_expressions">Complex Expressions</a></li>
<li><a href="#_conditions">Conditions</a></li>
<li><a href="#_custom_expressions">Custom Expressions</a></li>
<li><a href="#sorter">Sorters</a></li>
</ul>
</li>
<li><a href="#column_ops">Column Operations</a>
<ul class="sectlevel2">
<li><a href="#_pick_columns">Pick Columns</a></li>
<li><a href="#_rename_columns">Rename Columns</a></li>
<li><a href="#column_ops_transform">Transform Columns</a></li>
<li><a href="#column_ops_split">Split Columns</a></li>
<li><a href="#_merge_columns">Merge Columns</a></li>
<li><a href="#_compact_columns">Compact Columns</a></li>
<li><a href="#_fill_nulls">Fill Nulls</a></li>
<li><a href="#_drop_columns">Drop Columns</a></li>
<li><a href="#understanding_columnset">Understanding ColumnSet</a></li>
</ul>
</li>
<li><a href="#row_ops">Row Operations</a>
<ul class="sectlevel2">
<li><a href="#_pick_rows">Pick Rows</a></li>
<li><a href="#_transform_rows">Transform Rows</a></li>
<li><a href="#_merge_rows">Merge Rows</a></li>
<li><a href="#_split_rows">Split Rows</a></li>
<li><a href="#_unique_rows">Unique Rows</a></li>
<li><a href="#_drop_rows">Drop Rows</a></li>
</ul>
</li>
<li><a href="#row_column_ops">Row and Column Operations</a>
<ul class="sectlevel2">
<li><a href="#_pick_rows_and_columns">Pick Rows and Columns</a></li>
<li><a href="#_transform_rows_and_columns">Transform Rows and Columns</a></li>
<li><a href="#_merge_rows_and_columns">Merge Rows and Columns</a></li>
<li><a href="#_drop_rows_and_columns">Drop Rows and Columns</a></li>
</ul>
</li>
<li><a href="#head_tail">Head and Tail</a></li>
<li><a href="#sorting">Sorting</a>
<ul class="sectlevel2">
<li><a href="#_sort_series">Sort Series</a></li>
<li><a href="#_sort_dataframe">Sort DataFrame</a></li>
</ul>
</li>
<li><a href="#_concatenation">Concatenation</a>
<ul class="sectlevel2">
<li><a href="#_concatenate_series">Concatenate Series</a></li>
<li><a href="#_concatenate_dataframes">Concatenate DataFrames</a></li>
</ul>
</li>
<li><a href="#joins">Joins</a>
<ul class="sectlevel2">
<li><a href="#_inner_joins">Inner Joins</a></li>
<li><a href="#_column_namespace">Column Namespace</a></li>
<li><a href="#_transform_columns">Transform Columns</a></li>
<li><a href="#_outer_joins">Outer Joins</a></li>
<li><a href="#_indicator_column">Indicator Column</a></li>
<li><a href="#_nested_loop_joins">Nested Loop Joins</a></li>
</ul>
</li>
<li><a href="#group_aggregate">Group and Aggregate</a></li>
<li><a href="#window">Window Operations</a>
<ul class="sectlevel2">
<li><a href="#_row_ranking">Row Ranking</a></li>
</ul>
</li>
<li><a href="#pivot">Pivot</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#udfs">User-Defined Functions</a></li>
<li><a href="#jdbc">Using Relational Databases</a>
<ul class="sectlevel2">
<li><a href="#_jdbcconnector">JdbcConnector</a></li>
<li><a href="#_tableloader_tablesaver">TableLoader / TableSaver</a></li>
<li><a href="#_sqlloader_sqlsaver">SqlLoader / SqlSaver</a></li>
</ul>
</li>
<li><a href="#csv">CSV Format</a>
<ul class="sectlevel2">
<li><a href="#_reading_csv">Reading CSV</a></li>
<li><a href="#_writing_csv">Writing CSV</a></li>
</ul>
</li>
<li><a href="#excel">Excel Format</a></li>
<li><a href="#avro">Avro Format</a>
<ul class="sectlevel2">
<li><a href="#_avro_schema">Avro Schema</a></li>
</ul>
</li>
<li><a href="#parquet">Parquet Format</a></li>
<li><a href="#json">JSON Format</a>
<ul class="sectlevel2">
<li><a href="#_reading_json">Reading JSON</a></li>
<li><a href="#_writing_json">Writing JSON</a></li>
</ul>
</li>
<li><a href="#bin_data_sources">Binary Data Sources</a>
<ul class="sectlevel2">
<li><a href="#_byte_array_bytesource">Byte Array ByteSource</a></li>
<li><a href="#_url_bytesource">URL ByteSource</a></li>
<li><a href="#_http_bytesource">HTTP ByteSource</a></li>
</ul>
</li>
<li><a href="#jshell">Using JShell</a></li>
<li><a href="#jupyter">Using Jupyter Notebook</a>
<ul class="sectlevel2">
<li><a href="#_change_display_parameters">Change Display Parameters</a></li>
</ul>
</li>
<li><a href="#echarts">Charting with ECharts</a>
<ul class="sectlevel2">
<li><a href="#_line_charts">Line Charts</a></li>
<li><a href="#_bar_charts">Bar Charts</a></li>
<li><a href="#_scatter_charts">Scatter Charts</a></li>
<li><a href="#_pie_charts">Pie Charts</a></li>
<li><a href="#_candlestick_charts">Candlestick Charts</a></li>
</ul>
</li>
<li><a href="#unit-testing">Unit Testing</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>"DFLib" (short for "DataFrame Library") is a lightweight, pure Java implementation of <code>DataFrame</code>. <code>DataFrame</code> is a
very common structure in data science and Big Data worlds. It provides operations like search,
filtering, joins, aggregations, statistical functions, etc., that are reminiscent of SQL (also of Excel), except you run
them in your app over dynamic in-memory data sets.</p>
</div>
<div class="paragraph">
<p>There are <code>DataFrame</code> implementations in Python (<a href="https://pandas.pydata.org/">pandas</a>), R,
<a href="https://spark.apache.org/docs/latest/sql-programming-guide.html#datasets-and-dataframes">Apache Spark</a>, etc.
DFLib project&#8217;s goal is to provide the same functionality for regular Java applications. It is a simple library, that
requires no special infrastructure. DFLib core is dependency-free.</p>
</div>
<div class="paragraph">
<p>The code in this documentation can be run in any Java IDE, as well as (and this is pretty cool!) in a <a href="#jupyter">Jupyter notebook</a>. You will need Java 11 or newer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_get_started_with_dflib">Get Started with DFLib</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Include DFLib in a project. Assuming you are using Maven, start by declaring a "BOM" to have a common version for
multiple DFLib modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencyManagement&gt;</span>
  <span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
      <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
      <span class="tag">&lt;artifactId&gt;</span>dflib-bom<span class="tag">&lt;/artifactId&gt;</span>
      <span class="comment">&lt;!-- &quot;2.0.0-M1&quot; version will be released soon. Stay put --&gt;</span>
      <span class="tag">&lt;version&gt;</span>2.0.0-M1<span class="tag">&lt;/version&gt;</span>
      <span class="tag">&lt;type&gt;</span>pom<span class="tag">&lt;/type&gt;</span>
      <span class="tag">&lt;scope&gt;</span>import<span class="tag">&lt;/scope&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
  <span class="tag">&lt;/dependencies&gt;</span>
<span class="tag">&lt;/dependencyManagement&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next include DFLib core as a dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Create a DataFrame, do some manipulations with it, print the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = DataFrame
        .foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)
        .ofStream(IntStream.range(<span class="integer">1</span>, <span class="integer">10000</span>));

DataFrame df2 = df1.rows(r -&gt; r.getInt(<span class="integer">0</span>) % <span class="integer">2</span> == <span class="integer">0</span>).select();

<span class="predefined-type">System</span>.out.println(Printers.tabular.toString(df2));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this code, console output will look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   a    b    c
---- ---- ----
   4    5    6
  10   11   12
  16   17   18
...
9982 9983 9984
9988 9989 9990
9994 9995 9996
1666 rows x 3 columns</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We&#8217;ll omit print statements in all the following examples, and will simply display their output. Details of
printing are discussed in the in <a href="#printers">"Printers" chapter</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_main_data_structures">Main Data Structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The two essential DFLib classes are <code>Series</code> and <code>DataFrame</code>. <code>Series</code> is a 1-dimensional array-like object, and <code>DataFrame</code>
is a 2-dimensional table-like object. Columns in a DataFrame are stored as Series. Additionally, we will discuss
<code>Index</code> object that stores DataFrame column names.</p>
</div>
<div class="paragraph">
<p>Both DataFrame and Series (and Index) are fully <em>immutable</em>, so all operations on them return a new instance. Behind
the scenes the library shares as much data as possible between instances, so copying these objects does not cause
significant performance degradation, and in turn makes DFLib fully thread-safe, with multiple concurrent operations
possible on the same data structure. Also, immutability means that you can have full snapshots of your data at each
step of a transformation, simplifying debugging and auditing of data pipelines.</p>
</div>
<div class="sect2">
<h3 id="_series">Series</h3>
<div class="paragraph">
<p><code>Series</code> is the simplest of the two data structures. You can think of it as a wrapper around an array of values.
You can use <code>Series</code> to model sequences of data such as timestamps in a time series. Series object is parameterized for
the type of data that it holds. So there can be <code>Series&lt;String&gt;</code> or a <code>Series&lt;LocalDate&gt;</code>, etc. There is also an
important category of "primitive" Series (<code>IntSeries</code>, <code>LongSeries</code>, <code>DoubleSeries</code>, <code>BooleanSeries</code>) that are optimized
for memory use and arithmetic operations. Of course, each primitive Series can also pose as Series of a corresponding
wrapper object type (e.g. <code>IntSeries</code> is also a <code>Series&lt;Integer&gt;</code>).</p>
</div>
<div class="paragraph">
<p><code>Series</code> object is an important building block of DataFrame, but it defines a number of useful data
manipulation and transformation operations on its own. Those will be covered in the following chapters. Here we&#8217;ll
discuss how to create Series.</p>
</div>
<div class="sect3">
<h4 id="_creation_of_series_from_arrays">Creation of Series from Arrays</h4>
<div class="paragraph">
<p><code>Series</code> can be created using static <code>ofXyz(..)</code> methods on the <code>Series</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; s = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bcd</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">ef</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">g</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>a
bcd
...
g
4 elements</pre>
</div>
</div>
<div class="paragraph">
<p>Primitive Series classes have their own factory methods. E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">IntSeries is = Series.ofInt(<span class="integer">0</span>, <span class="integer">1</span>, -<span class="integer">300</span>, <span class="predefined-type">Integer</span>.MAX_VALUE);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creation_of_series_by_element">Creation of Series By Element</h4>
<div class="paragraph">
<p>If we don&#8217;t have a data array or collection to start with and instead somehow produce a sequence of
values of unpredictable length, we can use <code>Series.byElement()</code> API. E.g. the following example reads data from
an InputStream line by line as Strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// InputStream inputStream = ...</span>
SeriesAppender&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; appender = Series
        .byElement(Extractor.&lt;<span class="predefined-type">String</span>&gt;<span class="error">$</span>col()) <i class="conum" data-value="1"></i><b>(1)</b>
        .appender();

<span class="predefined-type">Scanner</span> scanner = <span class="keyword">new</span> <span class="predefined-type">Scanner</span>(inputStream);
<span class="keyword">while</span> (scanner.hasNext()) {
    appender.append(scanner.next()); <i class="conum" data-value="2"></i><b>(2)</b>
}

Series&lt;<span class="predefined-type">String</span>&gt; s = appender.toSeries();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create Series "appender" that will accumulate values. For primitive Series you would use <code>Extractor.$int(..)</code>,
<code>Extractor.$long(..)</code> and so on</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Append values as they are read one-by-one</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dataframe">DataFrame</h3>
<div class="paragraph">
<p><code>DataFrame</code> is an in-memory table made of an <code>Index</code> header and a number of named columns. Each column is
a <code>Series</code>, and has an associated name in the <code>Index</code>. <code>DataFrame</code> can contain columns of different
kinds, so it is not parameterized for any single type.</p>
</div>
<div class="paragraph">
<p>"Rows" is a purely virtual concept as the data is organized by column, yet there is a number of APIs that appear to
operate on rows for user convenience.</p>
</div>
<div class="paragraph">
<p>There are a few ways to create a DataFrame. Here we&#8217;ll show how to convert various in-memory objects to DataFrames
(arrays, Streams, Collections, Series).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
More often than not, a DataFrame is not created from an in-memory object, but is rather loaded from (and saved to) an
external source, like a <a href="#jdbc">database</a> or a <a href="#csv">CSV file</a>. Those are discussed in separate chapters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>First example, adding data row by row:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .byArrayRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .appender() <i class="conum" data-value="2"></i><b>(2)</b>
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="integer">18</span>)   <i class="conum" data-value="3"></i><b>(3)</b>
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="integer">49</span>)
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">32</span>)
        .toDataFrame();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A special builder is created to append each row as a vararg array</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The builder creates an "appender" object. While here we are using the builder with default settings, it has extra
methods to configure capacity, data sampling, etc.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Passing individual rows to the appender one-by-one</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resulting DataFrame looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name   age
------ ---
Joe    18
Andrus 49
Joan   32</pre>
</div>
</div>
<div class="paragraph">
<p>A more general example - creating a DataFrame from a list of objects by "extracting" column data from object properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">record Person(<span class="predefined-type">String</span> name, <span class="type">int</span> age) {
}

<span class="predefined-type">List</span>&lt;Person&gt; people = <span class="predefined-type">List</span>.of(
        <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="integer">18</span>),
        <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="integer">49</span>),
        <span class="keyword">new</span> Person(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">32</span>));

DataFrame df = DataFrame
        .byRow( <i class="conum" data-value="1"></i><b>(1)</b>
                Extractor.<span class="error">$</span>col(Person::name),
                Extractor.<span class="error">$</span><span class="type">int</span>(Person::age))
        .columnNames(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
        .appender() <i class="conum" data-value="3"></i><b>(3)</b>
        .append(people)   <i class="conum" data-value="4"></i><b>(4)</b>
        .toDataFrame();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The builder is started with an array of Extractors. Each extractor generates its own column, filling it with a
corresponding object property.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Specifying the names of the DataFrame columns. If omitted, column names are assigned automatically</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating a row-by-row appender</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Appending the list.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resulting DataFrame looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name   age
------ ---
Joe    18
Andrus 49
Joan   32</pre>
</div>
</div>
<div class="paragraph">
<p>Another example - a single-dimensional array can be "folded" into a DataFrame row-by-row:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .of(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="integer">18</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="integer">49</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">32</span>); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Folding Builder is created</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Passing a varargs array of values, that is folded to match the specified number of columns, row by row.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Same, but folding column-by-column:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .foldByColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>)
        .of(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">18</span>, <span class="integer">49</span>, <span class="integer">32</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also create DataFrames from collections or Streams (folded either by row or by column). Here is an example
of how to use a Stream of primitive ints, creating a DataFrame made of memory-efficient <code>IntSeries</code> columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .foldByColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">col1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">col2</span><span class="delimiter">&quot;</span></span>)
        .ofStream(IntStream.range(<span class="integer">0</span>, <span class="integer">10000</span>));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>col1 col2
---- ----
   0 5000
   1 5001
   2 5002
...
4997 9997
4998 9998
4999 9999
5000 rows x 2 columns</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, a DataFrame can be created from an array of Series, each Series representing a column:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .byColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>)
        .of(
                Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>),
                Series.ofInt(<span class="integer">18</span>, <span class="integer">49</span>, <span class="integer">32</span>)
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the most efficient way, as an array of Series is how each DataFrame is structured internally.</p>
</div>
</div>
<div class="sect2">
<h3 id="index">Index</h3>
<div class="paragraph">
<p><code>Index</code> is somewhat similar to Series. It serves as a <code>DataFrame</code> "header" and internally allows to quickly resolve
column String labels to their numeric positions. You&#8217;d work with <code>Index</code> instances outside a DataFrame only
occasionally, but it is still good to know its capabilities. E.g., here is how to get all the column labels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span><span class="type">[]</span> labels = df.getColumnsIndex().toArray();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="printers">Printers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When doing data exploration and running data pipelines, it is important to be able to visualize data at every step.
More advanced forms of visualization include charts and diagrams. But the simplest thing you can do is printing
data to the console. Both <code>DataFrame</code> and <code>Series</code> implement <code>toString()</code> method, that will print their contents
as a single line, truncating large data sets in the process, which is good for debugging applications running on a
server.</p>
</div>
<div class="paragraph">
<p>A more human-friendly form of output is produced by a <em>tabular</em> printer. Here is how to use the default tabular
printer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .foldByColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">col1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">col2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">col3</span><span class="delimiter">&quot;</span></span>)
        .ofStream(IntStream.range(<span class="integer">0</span>, <span class="integer">10000</span>));

<span class="predefined-type">String</span> table = Printers.tabular.toString(df);
<span class="predefined-type">System</span>.out.println(table);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It prints the data as follows, displaying at most 6 rows and truncating the rest. Same goes for cell values. Values
longer than 30 chars are also truncated (since they are pretty short in our example, value truncation is not obvious here).</p>
</div>
<div class="listingblock">
<div class="content">
<pre>col1 col2 col3
---- ---- ----
   0 3334 6668
   1 3335 6669
   2 3336 6670
...
3331 6665 9999
3332 6666    0
3333 6667    0
3334 rows x 3 columns</pre>
</div>
</div>
<div class="paragraph">
<p>You can change the truncation parameters by creating your own printer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Printer printer = <span class="keyword">new</span> TabularPrinter(<span class="integer">3</span>, <span class="integer">3</span>); <i class="conum" data-value="1"></i><b>(1)</b>
<span class="predefined-type">String</span> table = printer.toString(df);
<span class="predefined-type">System</span>.out.println(table);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a printer that displays at most 3 rows and up to 3 characters in each cell.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>c.. c.. c..
--- --- ---
  0 3.. 6..
  1 3.. 6..
...
3.. 6..   0
3334 rows x 3 columns</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using <a href="#jupyter">Jupyter Notebook</a>, all the printers are already setup for you. So if the last
statement in a Jupyter cell is a <code>DataFrame</code> or a <code>Series</code>, it will be printed as a table in the notebook.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions">Expressions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DFLib has a built-in expression language (implemented as a Java "DSL"). It allows to perform column-centric
operations on DataFrames and Series, such as data transformation, aggregation and filtering. <code>Exp</code> is the interface
representing an expression that takes either a DataFrame or a Series and produces a Series of the specified type.</p>
</div>
<div class="paragraph">
<p>To use expressions, you&#8217;d often start by adding a static import of the <code>Exp</code> interface, so that all its factory methods
are available directly in the code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">static</span> <span class="include">org.dflib.Exp</span>.*;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s create two simple expressions that return a named and a positional column of the requested type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">StrExp lastExp = <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>);
DecimalExp salaryExp = <span class="error">$</span>decimal(<span class="integer">2</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now let&#8217;s evaluate the expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">BigDecimal</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">120000</span><span class="delimiter">&quot;</span></span>),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">BigDecimal</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">80000</span><span class="delimiter">&quot;</span></span>),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">BigDecimal</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">95000</span><span class="delimiter">&quot;</span></span>));

Series&lt;<span class="predefined-type">String</span>&gt; last = lastExp.eval(df);
Series&lt;<span class="predefined-type">BigDecimal</span>&gt; salary = salaryExp.eval(df);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn&#8217;t look like much (other DFLib APIs would do the same), but this basic abstraction allows to describe a
wide range of operations (filtering, sorting, aggregation, etc). Expressions are rarely evaluated standalone. More
commonly they are passed as arguments to various other methods, as described below.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DFLib expressions work on Series instead of individual values, so they can achieve the best possible performance
for any given operation. Expressions should be the preferred way to manipulate your data instead of more "direct" APIs,
such as custom lamdas.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at various types of expressions&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_column_expressions">Column Expressions</h3>
<div class="paragraph">
<p><code>$str(..)</code> and <code>$decimal(..)</code> expressions in the example above are the column lookup expressions. They return a DataFrame
column with a given name or at a given (zero-based) position without applying any transformations to the data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
So what is returned when you evaluate a column expression with a Series object? Series can be thought of as a
single (unnamed) column. So a column expression simply returns the Series unchanged, ignoring implied column
name or position.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Factory methods for column expressions are easy to spot in the <code>Exp</code> interface - they all start with a dollar sign:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>

<i class="conum" data-value="2"></i><b>(2)</b>
<span class="error">$</span>decimal(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span><span class="type">double</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span><span class="type">long</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);

<i class="conum" data-value="3"></i><b>(3)</b>
<span class="error">$</span>date(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span>dateTime(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span>time(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);

<i class="conum" data-value="4"></i><b>(4)</b>
<span class="error">$</span>bool(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);
<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieves a column without implying a specific type</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Retrieve columns that are expected to be numeric</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Retrieve columns that are expected to be date/time</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Retrieve columns of boolean or String types</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Return type is implied from the method name (<code>$str(..)</code> produces a <code>Series&lt;String&gt;</code>, <code>$decimal(..)</code> -
<code>Series&lt;BigDecimal&gt;</code>, <code>$int(..)</code> - <code>Series&lt;Integer&gt;</code>, <code>$date(..)</code> - <code>Series&lt;LocalDate&gt;</code> and so on).</p>
</div>
<div class="paragraph">
<p>To avoid overhead, column expressions do not perform any type conversions of the column data (with a notable exception
of <code>$bool</code> that does). So you need to pick the right type in your code based on your knowledge of data to avoid
<code>ClassCastExceptions</code> downstream, or use a generic <code>$col(..)</code> expression. If you do want to convert data from one type
to another, use one of the <code>castAs</code> methods explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).castAsDecimal();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>castAs</code> will do its best to provide a meaningful conversion to the target type. But sometimes it is simply not possible,
and it will throw an exception (e.g. a String like "abcd" can&#8217;t be converted to a number without some contextual knowledge).
In some other cases, no default conversion exists, but a custom conversion is possible and desired. You can do it via
<code>Exp.mapVal(..)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_constant_expressions">Constant Expressions</h3>
<div class="paragraph">
<p>If we want to generate a Series with the same repeating value, we can use the <code>$val(..)</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; hi = <span class="error">$</span>val(<span class="string"><span class="delimiter">&quot;</span><span class="content">hi!</span><span class="delimiter">&quot;</span></span>).eval(df);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>hi!
hi!
hi!</pre>
</div>
</div>
<div class="paragraph">
<p>A useful case for <code>$val(..)</code> is to create a separator for String concatenation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; fn = concat( <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>),
        <span class="error">$</span>val(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>), <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>)).eval(df);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is a static import of <code>Exp.concat(..)</code>, an expression that takes a variable number of arguments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Inserting space between first and last name</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>Jerry Cosin
Juliana Walewski
Joan O'Hara</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_string_expressions">String Expressions</h3>

</div>
<div class="sect2">
<h3 id="_numeric_expressions">Numeric Expressions</h3>
<div class="paragraph">
<p><code>$int(..)</code>, <code>$long(..)</code>, <code>double(..)</code> and <code>$decimal(..)</code> columns expressions mentioned above are numeric (i.e. instances
of <code>NumExp</code> expression subclass), and as such, they provide arithmetics, comparison operations, and numeric aggregating
operations.</p>
</div>
<div class="paragraph">
<p>We will look at comparisons later in the "Conditions" chapter. Here is an example of arithmetics operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">NumExp&lt;?&gt; exp = <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>)
        .add(<span class="error">$</span><span class="type">long</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>)) <i class="conum" data-value="1"></i><b>(1)</b>
        .div(<span class="integer">2</span>.); <i class="conum" data-value="2"></i><b>(2)</b>

DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).of(
                <span class="integer">1</span>, <span class="integer">2L</span>,
                <span class="integer">3</span>, <span class="integer">4L</span>)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).select(exp);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Add two columns</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Multiply the result by a constant value</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre> c3
---
1.5
3.5</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Associativity&#8230;&#8203; Since expressions are built with Java API, there are no special associativity rules.
Expressions are executed in the order they were chained together. In the example above, addition happens before
division.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Widening conversions&#8230;&#8203; When we added values of <code>int</code> and <code>long</code> columns, the result was implicitly widened to <code>long</code>,
and later when it was divided by a <code>double</code>, the result became <code>double</code>. These conversions happen automatically and transparently
to the user. They follow regular Java rules for primitive numbers operations (with an addition of widening from
primitives to <code>BigDecimal</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of aggregating operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">NumExp&lt;?&gt; exp = <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>)
        .add(<span class="error">$</span><span class="type">long</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>))
        .sum() <i class="conum" data-value="1"></i><b>(1)</b>
        .div(<span class="integer">2</span>.);

DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).of(
                <span class="integer">1</span>, <span class="integer">2L</span>,
                <span class="integer">3</span>, <span class="integer">4L</span>)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c3</span><span class="delimiter">&quot;</span></span>).agg(exp);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inserting an aggregating expression in a chain of arithmetic expressions produces an aggregated result</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre> c3
---
5.0</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_date_expressions">Date Expressions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_complex_expressions">Complex Expressions</h3>
<div class="paragraph">
<p>Expressions can be expanded by calling methods on the <code>Exp</code> object (and its type-specific subclasses). As we&#8217;ve already
seen above, expressions can be composed of other expressions by invoking static methods of <code>Exp</code>. E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><i class="conum" data-value="1"></i><b>(1)</b>
<span class="predefined-type">Condition</span> c = and( <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>), <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="error">$</span>decimal(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).add(<span class="error">$</span>decimal(<span class="string"><span class="delimiter">&quot;</span><span class="content">benefits</span><span class="delimiter">&quot;</span></span>)).gt(<span class="integer">100000</span>.) <i class="conum" data-value="4"></i><b>(4)</b>
);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"Condition" is an <code>Exp&lt;Boolean&gt;</code> described in more detail below</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>and(..)</code> is a statically-imported <code>Exp.and(..)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>startsWith(..)</code> produces a condition based on another string expression</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>add(..)</code> produces an addition operation for two numeric expressions, <code>gt(..)</code> produces a condition from the result of the addition</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_conditions">Conditions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_custom_expressions">Custom Expressions</h3>
<div class="paragraph">
<p>Expression classes discussed above (<code>Exp</code>, <code>StrExp</code>, <code>NumExp</code>, etc.) define a large (and growing) number of operations,
yet there are always cases that require a custom transformation. There are a few flavors of expression factory methods
that take user-provided lambdas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>mapVal(..)</code> - value-to-value transformation</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Exp&lt;<span class="type">byte</span><span class="type">[]</span>&gt; bytes = <span class="error">$</span>decimal(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>)
        .mapVal(d -&gt; d.toBigInteger().toByteArray()); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the argument lambda takes a value and produces a value</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>map(..)</code> - Series-to-Series transformation. Unlike <code>mapVal(..)</code>, allows a custom lambda to access the
entire <code>Series</code>, and in some cases, optimize the operation (e.g. by avoiding scanning through all values)</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Exp&lt;<span class="predefined-type">Integer</span>&gt; exp = <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>)
        .map(s -&gt; Series.ofVal(s.get(<span class="integer">0</span>), s.size())); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the argument lambda takes the first value from the source <code>Series</code>, and produces the result Series of the same size
filled with that value</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>agg(..)</code> - Series-to-value transformation. This expression is used in the "aggregating" context (such as group or
window operations) where we need to produce a single value out of a <code>Series</code>:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Exp&lt;<span class="predefined-type">Integer</span>&gt; exp = <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">col</span><span class="delimiter">&quot;</span></span>)
        .agg(s -&gt; s.unique().size()); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the argument lambda counts unique values in a series, taking a <code>Series</code> and producing an int.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="sorter">Sorters</h3>
<div class="paragraph">
<p><code>Sorter</code> is a special object, that allows to <a href="#sorting">sort DFLib data structures</a>. Internally a Sorter is using an
expression to retrieve values that comprise sorting criteria and index them in the specified order. Sorter can be
created from any expression by calling its <code>asc()</code> or <code>desc()</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// sort by last name in the ascending order</span>
Sorter s = <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).asc();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DFLib would allow you to create a Sorter based on any expression type. In runtime, the actual type must be
either a Java primitive or an instance of <code>Comparable</code>, or a ClassCastException will be thrown during sorting.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="column_ops">Column Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To manipulate data in a single <code>DataFrame</code>, with a few exceptions you would start by picking a subset of columns or
rows. Those are represented as <code>ColumnSet</code> and <code>RowSet</code> objects. Let&#8217;s look at columns first&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_pick_columns">Pick Columns</h3>
<div class="paragraph">
<p>Columns are picked either by condition, by name, by position or implicitly. Let&#8217;s take a look at each style&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_by_condition">By Condition</h4>
<div class="paragraph">
<p>A condition is specified as a "predicate" lambda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.cols(c -&gt; !<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>.equals(c)).select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form of <code>cols(..)</code> does not allow to reorder the columns. The resulting columns will always follow the relative
order of the original <code>DataFrame</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last
------- --------
Jerry   Cosin
Joan    O'Hara</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_by_names">By Names</h4>
<div class="paragraph">
<p>Here is a simple example of how to pick two columns from a DataFrame by name, and return a new DataFrame with
just those two columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .select(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define a <code>ColumnSet</code> of two columns matching provided names.
The order of columns in the <code>ColumnSet</code> matches the order of column names passed to this method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Return a new DataFrame matching the <code>ColumnSet</code>. More on this in the next chapter.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>last     first
-------- -------
Cosin    Jerry
O'Hara   Joan</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Passing names in a specific order to <code>cols(..)</code> allowed us to reorder the columns in the result.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Instead of listing included columns, you might specify which columns should be <em>excluded</em> from selection. This flavor
doesn&#8217;t support reordering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.colsExcept(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).select();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_by_positions">By Positions</h4>
<div class="paragraph">
<p>You can also pick columns by positions. The first position is "0".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.cols(<span class="integer">1</span>, <span class="integer">0</span>).select();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="column_ops_implicit">Implicitly</h4>
<div class="paragraph">
<p>If you specify no columns at all when building a <code>RowSet</code>, the returned <code>DataFrame</code> will be the same as the source one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.cols().select();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this particular case, implicit column selection is not very useful. But in fact, this style is dynamic
and may result in a smaller subset of columns selected based on the semantics of an operation applied to the
<code>ColumnSet</code> (e.g. named expressions making specific columns). Also, it allows to apply a <em>transformation</em> to
all columns at once. These cases are described later in the <a href="#column_ops_transform">columns transformation</a> chapter.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rename_columns">Rename Columns</h3>
<div class="paragraph">
<p>We saw how we can select a subset of columns. While doing that, we can also assign new names to all or some of the
columns via <code>selectAs(..)</code>.</p>
</div>
<div class="paragraph">
<p>Rename all column set columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
        .selectAs(<span class="string"><span class="delimiter">&quot;</span><span class="content">last_name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first_name</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Passing new names for the <code>ColumnSet</code> columns. The order of the names must correspond to the order of columns
in the <code>ColumnSet</code>, regardless of how it was defined.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>last_name first_name
--------- ----------
Cosin     Jerry
Walewski  Juliana</pre>
</div>
</div>
<div class="paragraph">
<p>Rename a subset of columns. Specifying names of all columns at once may not be practical for
"wide" column sets. Instead, you can pass a map of old to new names to <code>selectAs(..)</code> to rename just some columns.
Names not present in the map will remain unchanged:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
        .selectAs(<span class="predefined-type">Map</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">LAST_NAME</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>LAST_NAME first
--------- -------
Cosin     Jerry
O'Hara    Joan</pre>
</div>
</div>
<div class="paragraph">
<p>Rename with a function, applied to all column names in turn. This is useful e.g. to convert all names to lower or
upper case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
        .selectAs(<span class="predefined-type">String</span>::toUpperCase);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>LAST   FIRST
------ -----
Cosin  Jerry
O'Hara Joan</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="column_ops_transform">Transform Columns</h3>
<div class="paragraph">
<p>In the above examples we performed <code>DataFrame</code> vertical slicing, columns reordering and renaming. In this chapter
we&#8217;ll show how to transform column data.</p>
</div>
<div class="paragraph">
<p>Generating columns with expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Exp fmExp = concat(
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>),
        ifNull(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).mapVal(s -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + s), <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>));

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">first_middle</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .select(fmExp, <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>When defining the <code>ColumnSet</code>, we are allowed to specify columns that are not present in the original DataFrame, as
we are naming the result columns, not the source columns.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For each column in the <code>ColumnSet</code>, there should be an expression that generates the column. The first expression
here transforms the data, the second simply picks a column from the source without modification.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first_middle last
------------ ------
Jerry M      Cosin
Joan         O'Hara</pre>
</div>
</div>
<div class="paragraph">
<p>Generating columns row-by-row with <code>RowMapper</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">RowMapper</span> mapper = (from, to) -&gt; {
    <span class="predefined-type">String</span> middle = from.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>) != <span class="predefined-constant">null</span>
            ? <span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span> + from.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>)
            : <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
    to.set(<span class="integer">0</span>, from.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>) + middle).set(<span class="integer">1</span>, from.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>));
};

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">first_middle</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>)
        .select(mapper);</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s also a way to generating columns row-by-row with per-column array of <code>RowToValueMapper</code>. It is not very different
from what we&#8217;ve seen so far, so we are leaving this as an exercise for the reader.</p>
</div>
</div>
<div class="sect2">
<h3 id="column_ops_split">Split Columns</h3>
<div class="paragraph">
<p>Values can be split using an expression into iterable or array elements, and new columns can be generated
from those elements, thus "expanding" each row. Here is an example of handling Lists of values (<code>List</code> is, of course,
an <code>Iterable</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">111-555-5555</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">111-666-6666</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">111-777-7777</span><span class="delimiter">&quot;</span></span>),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">222-555-5555</span><span class="delimiter">&quot;</span></span>));

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">primary_phone</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">secondary_phone</span><span class="delimiter">&quot;</span></span>)
        .selectExpand(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>selectExpand(..)</code> takes an expression that returns a column with lists. If each List has more than 2 numbers,
the rest are ignored, if less - nulls are used for the  missing elements</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>primary_phone secondary_phone
------------- ---------------
111-555-5555  111-666-6666
222-555-5555  null</pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t know the exact number of phones, but would like to capture them all in separate columns, do not
specify any explicit names (as mentioned in the <a href="#column_ops_implicit">implicit column selection</a> chapter).
As many columns as needed to fit the longest array of phone numbers will be generated on the fly, and the names will
be assigned dynamically:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols() <i class="conum" data-value="1"></i><b>(1)</b>
        .selectExpand(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Not specifying any columns will result in split columns generated dynamically.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>0            1            2
------------ ------------ ------------
111-555-5555 111-666-6666 111-777-7777
222-555-5555 null         null</pre>
</div>
</div>
<div class="paragraph">
<p>If the phone numbers were provided as a comma-separated <code>String</code> instead of a <code>List</code>, you can split the String into an
array of numbers using the <code>split(..)</code> expression, and use <code>selectExpandArray(..)</code> to generate the columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">111-555-5555,111-666-6666,111-777-7777</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">222-555-5555</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">primary_phone</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">secondary_phone</span><span class="delimiter">&quot;</span></span>)
        .selectExpandArray(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>).split(<span class="string"><span class="delimiter">'</span><span class="content">,</span><span class="delimiter">'</span></span>));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merge_columns">Merge Columns</h3>
<div class="paragraph">
<p>The <code>ColumnSet</code> operations demonstrated so far resulted in discarding the source <code>DataFrame</code>, and returning only the
columns defined within the set. But often we would like to recombine transformed <code>ColumnSet</code> with the original
<code>DataFrame</code>. Any in-place data cleanup, data set enrichment, etc. fall in this category.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Of course, we call them "in-place" only in a logical sense, as <code>DataFrame</code> is immutable, and all modifications
result in creation of a new instance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this <code>ColumnSet</code> provides a number of "merging" methods. All the <code>ColumnsSet</code> methods that do not start with
<code>select&#8230;&#8203;</code> are performing a merge with the source DataFrame. In fact, all the renaming and data transformation
operations that we just discussed can also be executed as "merges".</p>
</div>
<div class="paragraph">
<p>Here is an example of cleaning up a data set and adding a new column:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);

Function&lt;<span class="predefined-type">String</span>, Exp&lt;<span class="predefined-type">String</span>&gt;&gt; cleanup = col -&gt; <span class="error">$</span>str(col).mapVal(
        s -&gt; s != <span class="predefined-constant">null</span> &amp;&amp; !s.isEmpty()
                ? <span class="predefined-type">Character</span>.toUpperCase(s.charAt(<span class="integer">0</span>)) + s.substring(<span class="integer">1</span>)
                : <span class="predefined-constant">null</span>); <i class="conum" data-value="1"></i><b>(1)</b>

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">full</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
        .merge( <i class="conum" data-value="3"></i><b>(3)</b>
                cleanup.apply(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>),
                cleanup.apply(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>),
                concat(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>), <span class="error">$</span>val(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>), <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>))
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An expression that capitalizes the first letter of the name</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The columns we are going to generate or transform</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Instead of <code>select(..)</code>, use <code>merge(..)</code> to combine columns with the original DataFrame</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now let&#8217;s check the result. The first two columns in the <code>ColumnSet</code> ("last", "first") were  already present in the
DataFrame, so they got replaced with the cleaned up versions. The last column ("full") was new, so it was appended to
the right side of the DataFrame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>first last   middle full
----- ------ ------ -----------
Jerry Cosin  M      jerry cosin
Joan  O'Hara null   Joan O'Hara</pre>
</div>
</div>
<div class="paragraph">
<p>General merge rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Merging is done <strong>by name</strong>. DataFrame&#8217;s columns with matching names are replaced with new versions, columns that
are not a part of the <code>ColumnSet</code> are left unchanged, and columns in the <code>ColumnSet</code>, but not in the DataFrame, are
appended on the right.</p>
</li>
<li>
<p>The order of the existing columns in the <code>ColumnSet</code> has no effect on the order of replaced columns (i.e. they are
placed in their original positions). The relative order of appended columns is respected.</p>
</li>
<li>
<p>All transformation operations (such as expressions in our example) are applied to the original DataFrame columns
(and can reference those outside the <code>ColumnSet</code>), but do not see the transformed columns. This is why there is a
lowercase name in the resulting "full" column.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>What if we want to ensure that all of the <code>ColumnSet</code> columns are appended, and no replacement of the original columns
occurs? For this you can manually specify <code>ColumnSet</code> labels that are not found in the source DataFrame, or you can use
<code>DataFrame.colsAppend(..)</code>, and DFLib itself will ensure that the names are unique, appending <code>_</code> to each label until
it doesn&#8217;t overlap with anything already in the DataFrame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .colsAppend(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .merge(
                cleanup.apply(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>),
                cleanup.apply(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>colsAppend(..)</code> instead of <code>cols()</code> ensures that both pre- and post-cleanup columns are preserved.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first last   middle last_  first_
----- ------ ------ ------ ------
jerry cosin  M      Cosin  Jerry
Joan  O'Hara null   O'Hara Joan</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since we&#8217;ve already discussed various flavors of column renaming and transformation in the context of <code>select(..)</code>,
we leave it as an exercise for the user to explore their "merging" counterparts - <code>as(..)</code>, <code>map(..)</code>, <code>expand(..)</code>, etc.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_compact_columns">Compact Columns</h3>
<div class="paragraph">
<p>This transformation converts columns to primitives. The values in the columns to be converted can be Numbers, Booleans
or Strings (or objects with <code>toString()</code> that can be parsed to a primitive type):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">year</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">sales</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">2022</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">2005365.01</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">2023</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4355098.75</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">year</span><span class="delimiter">&quot;</span></span>).compactInt(<span class="integer">0</span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">sales</span><span class="delimiter">&quot;</span></span>).compactDouble(<span class="integer">0</span>.);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The argument to <code>compact</code> is the primitive value to use if the value being converted is null</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>compactInt(..)</code>, <code>compactDouble(..)</code> and other similar methods are not just syntactic sugar. They convert
DataFrame columns to primitive Series, that take <em>significantly</em> less memory (hence, the name "compact") and compute
most operations faster than Object-based Series. So you should consider using them where possible.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_fill_nulls">Fill Nulls</h3>
<div class="paragraph">
<p>As a part of a dataset cleanup effort, you might want to replace <code>null</code> values with something meaningful. For this you
may have to guess or maybe extrapolate the existing values based on some internal knowledge of the dataset. To help with
this task, <code>ColumnSet</code> provides a few methods discussed here.</p>
</div>
<div class="paragraph">
<p>Filling nulls with a constant value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">a1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">a2</span><span class="delimiter">&quot;</span></span>,
        <span class="predefined-constant">null</span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">b1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b2</span><span class="delimiter">&quot;</span></span>);

DataFrame clean = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).fillNulls(<span class="string"><span class="delimiter">&quot;</span><span class="content">X</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>c1 c2
-- --
a1 a2
X  X
b1 b2</pre>
</div>
</div>
<div class="paragraph">
<p>Filling nulls with values adjacent to the cells with nulls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame clean = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>).fillNullsBackwards() <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).fillNullsForward(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>fillNullsForward(..)</code> takes a non-null value preceding the null cell and uses it to replace nulls.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>fillNullsBackwards(..)</code> uses the first non-null value following the null cell.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>c1 c2
-- --
a1 a2
b1 a2
b1 b2</pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s also a way to fill nulls from another <code>Series</code> object used as a "mask" :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; mask = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">A</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">B</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">D</span><span class="delimiter">&quot;</span></span>);
DataFrame clean = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">c1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c2</span><span class="delimiter">&quot;</span></span>).fillNullsFromSeries(mask);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>c1 c2
-- --
a1 a2
B  B
b1 b2</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The "mask" <code>Series</code> can be longer or shorter than the <code>DataFrame</code> height. Values are aligned by position
starting at zero.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we can use an <code>Exp</code> to calculate values for nulls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>        DataFrame df = DataFrame.foldByRow("c1", "c2").of(
                "a1", "a2",
                null, null,
                "b1", "b2");

        DataFrame clean = df.cols("c1", "c2")
                .fillNullsWithExp(rowNum()); <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Exp.rowNum()</code> generates a <code>Series</code> with row numbers, so the nulls are replaced by the number denoting their position
in the <code>DataFrame</code>:</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>c1 c2
-- --
a1 a2
2  2
b1 b2</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_drop_columns">Drop Columns</h3>
<div class="paragraph">
<p>To get rid of certain columns in a DataFrame, you can either select the columns you would want to drop and call <code>drop()</code>
or select the columns you’d want to remain and call <code>select()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).drop();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.colsExcept(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, the result is the same:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>first last
----- ------
Jerry Cosin
Joan  O'Hara</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="understanding_columnset">Understanding ColumnSet</h3>
<div class="paragraph">
<p>Now that we&#8217;ve seen various ways how you can pick, rename and transform columns, let&#8217;s look at <code>ColumnSet</code> as a whole.
It is important to understand that no matter how a <code>ColumnSet</code> was created, its columns are always the <strong>result columns</strong>
of the operation, not the source DataFrame columns. They often reference names and positions of the source
columns and, in some cases, their values are copied directly from the source, but logically they always specify the result.</p>
</div>
<div class="paragraph">
<p>To illustrate the point, let&#8217;s first look a direct source-to-result copy example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
        .select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can change it a little, by adding a column to the <code>ColumnSet</code> that is not in the original
<code>DataFrame</code>, and it will still work (with the new column being filled with nulls):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>)
        .select();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>last   first middle
------ ----- ------
Cosin  Jerry null
O'Hara Joan  null</pre>
</div>
</div>
<div class="paragraph">
<p>Even when renaming, we are technically renaming <code>ColumnSet</code> columns (that may or may not come from the source), not the
source columns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>)
        .selectAs(<span class="string"><span class="delimiter">&quot;</span><span class="content">L</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">F</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>L      F     M
------ ----- ----
Cosin  Jerry null
O'Hara Joan  null</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="row_ops">Row Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just like with columns, row operations first define a <code>RowSet</code>, execute some transformation, and then are either
merged back with the original <code>DataFrame</code>, or "selected" as a standalone one. <code>RowSet</code> and <code>ColumnSet</code> have other
similarities (e.g. the ability to evaluate expressions by column, and create <code>RowColumnSet</code>), but <code>RowSet</code> is also
rather different in how its rows are picked and what other operations are available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The important similarity with <code>ColumnSet</code> is that <code>RowSet</code> rows, while often referencing source rows, always
define the <strong>result</strong> rows. See <a href="#understanding_columnset">"Understanding ColumnSet"</a> for a more detailed discussion.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_pick_rows">Pick Rows</h3>
<div class="paragraph">
<p>Rows are picked either by condition, by positions or as a range. Let&#8217;s take a look at each style&#8230;&#8203;</p>
</div>
<div class="sect3">
<h4 id="_by_condition_2">By Condition</h4>
<div class="paragraph">
<p>A <code>Condition</code> (a boolean <code>Exp</code>) can be used to pick matching rows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">P</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df
        .rows(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">W</span><span class="delimiter">&quot;</span></span>).eval(df)) <i class="conum" data-value="1"></i><b>(1)</b>
        .select(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Applies a <code>Condition</code> to the DataFrame, to include matching rows in the <code>RowSet</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns a new DataFrame matching the <code>RowSet</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last     middle
------- -------- ------
Juliana Walewski null</pre>
</div>
</div>
<div class="paragraph">
<p>Another form of condition is a "predicate" lambda (a <code>RowPredicate</code> object), evaluated row-by-row:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .rows(r -&gt; r.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">String</span>.class).startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">W</span><span class="delimiter">&quot;</span></span>))
        .select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A condition can be precalculated as a <code>BooleanSeries</code>. A common scenario is calling <code>locate()</code> on another <code>Series</code>
or a <code>DataFrame</code> / <code>RowSet</code> to build a <code>BooleanSeries</code> "selector", and then using it to pick rows from another DataFrame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">IntSeries salaries = Series.ofInt(<span class="integer">100000</span>, <span class="integer">50000</span>, <span class="integer">45600</span>); <i class="conum" data-value="1"></i><b>(1)</b>
BooleanSeries selector = salaries.locateInt(s -&gt; s &gt; <span class="integer">49999</span>); <i class="conum" data-value="2"></i><b>(2)</b>

DataFrame df1 = df.rows(selector).select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A Series of salaries with elements positions matching row positions in the persons DataFrame.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Precalculates a reusable "selector"</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last     middle
------- -------- ------
Jerry   Cosin    M
Juliana Walewski null</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_by_positions_2">By Positions</h4>
<div class="paragraph">
<p>Here is an example of <code>RowSet</code> defined using an array of row positions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .rows(<span class="integer">2</span>, <span class="integer">0</span>, <span class="integer">2</span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An <code>int[]</code> that defines a <code>RowSet</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first last   middle
----- ------ ------
Joan  O'Hara P
Jerry Cosin  M
Joan  O'Hara P</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An array of positions is also a kind of "condition". The main difference is that it allows
to reorder rows by specifying positions in a desired sequence and/or duplicate rows by referencing the same position more
than once. Both features are demonstrated in the example above.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Instead of an array, positions can be defined as an <code>IntSeries</code> "index". Just like with conditions, it is often
calculated from another <code>Series</code> or <code>DataFrame</code> / <code>RowSet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">IntSeries selector = salaries.indexInt(s -&gt; s &gt; <span class="integer">49999</span>); <i class="conum" data-value="1"></i><b>(1)</b>

DataFrame df1 = df.rows(selector).select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Precalculates a reusable "selector" with positions. Uses a Series of salaries that is not a part of "our" DataFrame</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last     middle
------- -------- ------
Jerry   Cosin    M
Juliana Walewski null</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_as_a_range">As a Range</h4>
<div class="paragraph">
<p>Finally, rows can be selected as a continuous range of row positions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .rowsRange(<span class="integer">0</span>, <span class="integer">2</span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The range is defined by two ints: its starting index and the index, following its last index.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last     middle
------- -------- ------
Jerry   Cosin    M
Juliana Walewski null</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transform_rows">Transform Rows</h3>
<div class="paragraph">
<p>Just like <code>ColumnSet</code>, <code>RowSet</code> defines a number of column- and row-based transformations. And just like with
<code>ColumnSet</code>, each transformation can be invoked as a "select" or a "merge", returning either the <code>RowSet</code> rows or all
rows from the original <code>DataFrame</code>. Here we will demonstrate selecting operations, and will talk about merging next.</p>
</div>
<div class="paragraph">
<p>Transforming with column expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">retires_soon</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="integer">61</span>, <span class="predefined-constant">false</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="integer">25</span>, <span class="predefined-constant">false</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="integer">59</span>, <span class="predefined-constant">false</span>);

DataFrame df1 = df
        .rows(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).mapBoolVal(a -&gt; <span class="integer">67</span> - a &lt; <span class="integer">10</span>))
        .select(
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span>val(<span class="predefined-constant">true</span>)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Select the rows from each column without changes, except the last one, where we flip the "retires_soon" flag
to "true".</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>last   age retires_soon
------ --- ------------
Cosin   61         true
O'Hara  59         true</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We had to specify an expression for every column in the DataFrame, even though only a single column got transformed.
This code can be improved by creating a <code>RowColumnSet</code> <a href="#row_column_ops">described here</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transforming row-by-row with <code>RowMapper</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">RowMapper</span> mapper = (from, to) -&gt; {
    from.copy(to);
    to.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">retires_soon</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>);
};

DataFrame df1 = df
        .rows(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).mapBoolVal(a -&gt; <span class="integer">67</span> - a &lt; <span class="integer">10</span>))
        .select(mapper);</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s also a way to transforming row-by-row with per-column array of <code>RowToValueMapper</code>. It is not very different
from what we&#8217;ve seen so far, so we are leaving this as an exercise for the reader.</p>
</div>
</div>
<div class="sect2">
<h3 id="_merge_rows">Merge Rows</h3>
<div class="paragraph">
<p>If we want to merge the result of a <code>RowSet</code> transformation to the original <code>DataFrame</code>, we&#8217;ll need to use methods
like <code>merge(..)</code> (i.e. those that do not start with <code>select</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">retires_soon</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="integer">61</span>, <span class="predefined-constant">false</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="integer">25</span>, <span class="predefined-constant">false</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="integer">59</span>, <span class="predefined-constant">false</span>);

DataFrame df1 = df
        .rows(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).mapBoolVal(a -&gt; <span class="integer">67</span> - a &lt; <span class="integer">10</span>))
        .merge(
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span>val(<span class="predefined-constant">true</span>));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>last     age retires_soon
-------- --- ------------
Cosin     61         true
Walewski  25        false
O'Hara    59         true</pre>
</div>
</div>
<div class="paragraph">
<p>Merging rows is done similar to columns, except rows have no name labels, so it is done by position. General merge rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Merging is done by row position. DataFrame rows with matching positions are replaced with transformed versions, rows that
are not a part of the <code>RowSet</code> are left unchanged, and rows in the <code>RowSet</code>, but not in the <code>DataFrame</code> (e.g.,
intentionally duplicated rows or split rows) are appended in the bottom.</p>
</li>
<li>
<p>The order of the existing rows in the <code>RowSet</code> has no effect on the order of replaced rows (i.e. they are
placed in their original positions). The relative order of added rows is respected.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Just like with columns, for most <code>RowSet.select(..)</code> methods there are "merging" counterparts, such as  <code>map(..)</code>,
<code>expand(..)</code>, <code>unique(..)</code>, etc.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_split_rows">Split Rows</h3>
<div class="paragraph">
<p>Splitting rows is somewhat simpler than <a href="#column_ops_split">splitting columns</a>. The API takes a single column
(no expression is allowed), and splits any expandable values into new rows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">List</span>.of(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">111-555-5555</span><span class="delimiter">&quot;</span></span>,
                <span class="string"><span class="delimiter">&quot;</span><span class="content">111-666-6666</span><span class="delimiter">&quot;</span></span>,
                <span class="string"><span class="delimiter">&quot;</span><span class="content">111-777-7777</span><span class="delimiter">&quot;</span></span>),
        <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">222-555-5555</span><span class="delimiter">&quot;</span></span>));

DataFrame df1 = df
        .rows()
        .selectExpand(<span class="string"><span class="delimiter">&quot;</span><span class="content">phones</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>name   phones
------ ------------
Cosin  111-555-5555
Cosin  111-666-6666
Cosin  111-777-7777
O'Hara 222-555-5555</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The expansion column can contain scalars, arrays or iterables.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_unique_rows">Unique Rows</h3>
<div class="paragraph">
<p>To deduplicate DataFrames, there&#8217;s an API to select fully or partially-unique rows. Uniqueness is checked either on
all columns of each row, or a preselected subset:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jones</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.rows().selectUnique(); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Keep only fully unique rows</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first last
----- ------
Jerry Cosin
Jerry Jones
Joan  O'Hara</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df2 = df.rows().selectUnique(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Deduplicate first names. Picking the row of each earliest-encountered unique first name.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first last
----- ------
Jerry Cosin
Joan  O'Hara</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_drop_rows">Drop Rows</h3>
<div class="paragraph">
<p>To get rid of certain rows in a DataFrame, you can either select the rows you would want to drop, and call <code>drop()</code>
or select the rows you’d want to remain and call <code>select()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">P</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.rows(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).isNull()).drop();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">P</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.rowsExcept(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).isNull()).select();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, the result is the same:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>first last   middle
----- ------ ------
Jerry Cosin  M
Joan  O'Hara P</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="row_column_ops">Row and Column Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect2">
<h3 id="_pick_rows_and_columns">Pick Rows and Columns</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_transform_rows_and_columns">Transform Rows and Columns</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_merge_rows_and_columns">Merge Rows and Columns</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_drop_rows_and_columns">Drop Rows and Columns</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="head_tail">Head and Tail</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As we&#8217;ve seen previously, most operations within a single DataFrame are performed on row and column sets. Still, some
are applied to the DataFrame directly. <code>head</code> and <code>tail</code> are such examples.</p>
</div>
<div class="paragraph">
<p>When you only need the "first N" or "last M" rows of a DataFrame (or values of a Series) you can use <code>head</code> and <code>tail</code>
operations. Here is how to get the top 2 rows of a DataFrame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.head(<span class="integer">2</span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns a new DataFrame with two top rows of the original DataFrame.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last
------- ---------
Jerry   Cosin
Juliana Walewski</pre>
</div>
</div>
<div class="paragraph">
<p><code>tail</code> works similarly, but returns the <em>last</em> N rows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.tail(<span class="integer">1</span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>first last
----- ------
Joan  O'Hara
1 row x 2 columns</pre>
</div>
</div>
<div class="paragraph">
<p>The argument to either <code>head(..)</code> or <code>tail(..)</code> can be negative.
In which case the operation skips the specified number of elements either from the top or from the bottom, and returns the remaining elements.
The following code returns a new DataFrame after skipping the two top rows of the original DataFrame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df.head(-<span class="integer">2</span>);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>first  last
------ ---------
Joan  O'Hara
1 row x 2 columns</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike index operations on arrays and lists in Java, <code>head(..)</code> and <code>tail(..)</code> are safe in regards to bounds checking.
They DO NOT throw exceptions when the length parameter is bigger than DataFrame height (or Series size), returning an empty DataFame (or Series) instead.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Series</code> also define <code>head(..)</code> and <code>tail(..)</code> that do what you&#8217;d expect, returning first or last N values.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sorting">Sorting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can sort values in <code>Series</code>, and sort rows in <code>DataFrames</code>. As is the case everywhere else in DFLib, sorting does
not alter the original object, and instead creates a new instance of either Series or DataFrame.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s look at sorting Series&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_sort_series">Sort Series</h3>
<div class="paragraph">
<p>Series provides a <code>sort</code> method to sort its data using a <a href="#sorter">sorter</a> built from an expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// sort series by String length</span>
Series&lt;<span class="predefined-type">String</span>&gt; s = Series
        .of(<span class="string"><span class="delimiter">&quot;</span><span class="content">12</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>)
        .sort(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).mapVal(<span class="predefined-type">String</span>::length).asc());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is a new Series with sorted data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1
12
123
3 elements</pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively the same can be achieved using a Comparator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; s = Series
        .of(<span class="string"><span class="delimiter">&quot;</span><span class="content">12</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>)
        .sort(<span class="predefined-type">Comparator</span>.comparingInt(<span class="predefined-type">String</span>::length));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example shows how to sort Series in the "natural" order (alphabetically for Strings):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; s = Series
        .of(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)
        .sort(<span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).asc());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>a
c
d
3 elements</pre>
</div>
</div>
<div class="paragraph">
<p>Series of primitives have methods to sort values in the natural order without an explicit sorter or comparator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">LongSeries s = Series
        .ofLong(<span class="predefined-type">Long</span>.MAX_VALUE, <span class="integer">15L</span>, <span class="integer">0L</span>)
        .sortLong();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>                  0
                 15
9223372036854775807
3 elements</pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, <code>IntSeries</code> has an optimized method to sort ints with a custom <code>IntComparator</code>.</p>
</div>
<div class="paragraph">
<p>Next we&#8217;ll check how to sort a DataFrame.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sort_dataframe">Sort DataFrame</h3>
<div class="paragraph">
<p>Rows in a DataFrame can be sorted with one or more <a href="#sorter">sorters</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Just like in other places where a Sorter might be
used, there is an assumption that the Sorter expression produces values that are either Java primitives or are
compatible with <code>java.lang.Comparable</code> (i.e., Strings, numbers, etc).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Albert</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">J</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.sort(
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>).asc(),
        <span class="error">$</span>str(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).asc());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last      middle
------- --------- ------
Juliana Walewski  null
Jerry   Albert    null
Jerry   Cosin     M
Joan    O'Hara    J</pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively sorting can be done by a single column name or an array of columns. The assumption is the same as above
- values in columns used for sorting must be either Java primitive or implement <code>java.lang.Comparable</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">J</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.sort(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The first argument is the column name (can also be column integer index), the second - a boolean indicating sort
direction (<code>true</code> for ascending, <code>false</code> - for descending order).</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">middle</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">M</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Albert</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">J</span><span class="delimiter">&quot;</span></span>);

DataFrame df1 = df.sort(<span class="keyword">new</span> <span class="predefined-type">String</span><span class="type">[]</span>{<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>}, <span class="keyword">new</span> <span class="type">boolean</span><span class="type">[]</span>{<span class="predefined-constant">true</span>, <span class="predefined-constant">false</span>});</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_concatenation">Concatenation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are various ways to combine data from multiple <code>Series</code> or <code>DataFrames</code>. The simplest is <em>concatenation</em>,
described in this chapter. Series can be concatenated together producing a longer Series. DataFrames can be concatenated
either vertically (along the rows axis) or horizontally (along the columns axis).</p>
</div>
<div class="sect2">
<h3 id="_concatenate_series">Concatenate Series</h3>
<div class="paragraph">
<p>If you have a Series object and want to concatenate it with one or more other Series, you&#8217;d use <code>Series.concat(..)</code>
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; s1 = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>);
Series&lt;<span class="predefined-type">String</span>&gt; s2 = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>);
Series&lt;<span class="predefined-type">String</span>&gt; s3 = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">n</span><span class="delimiter">&quot;</span></span>);

Series&lt;<span class="predefined-type">String</span>&gt; sConcat = s1.concat(s2, s3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is as expected contains values of all Series put together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>x
y
z
a
m
n
6 elements</pre>
</div>
</div>
<div class="paragraph">
<p>If you have a collection or an array of Series and want to "glue" them together, you can use a static
<code>SeriesConcat.concat(..)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Collection</span>&lt;Series&lt;<span class="predefined-type">String</span>&gt;&gt; ss = asList(
        Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">z</span><span class="delimiter">&quot;</span></span>),
        Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>),
        Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">m</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">n</span><span class="delimiter">&quot;</span></span>));

Series&lt;<span class="predefined-type">String</span>&gt; sConcat = SeriesConcat.concat(ss);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is the same as in the previous example. Also you can concatenate Series with itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Series&lt;<span class="predefined-type">String</span>&gt; s = Series.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>);
Series&lt;<span class="predefined-type">String</span>&gt; sConcat = s.concat(s);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>x
y
x
y
4 elements</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_concatenate_dataframes">Concatenate DataFrames</h3>
<div class="paragraph">
<p>DataFrame offers two options for concatenation - <em>vertical</em> (stacking DataFrames on top of each other) and <em>horizontal</em>
(putting them next to each other). Let&#8217;s see some examples..</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).of(
        <span class="integer">1</span>, <span class="integer">2</span>,
        <span class="integer">3</span>, <span class="integer">4</span>);

DataFrame df2 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).of(
        <span class="integer">5</span>, <span class="integer">6</span>,
        <span class="integer">7</span>, <span class="integer">8</span>);

DataFrame dfv = df1.vConcat(df2); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Concatenate this and another DataFrame vertically. The argument is a vararg, so more than one DataFrame can be
passed to the method.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b
- -
1 2
3 4
5 6
7 8</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame dfh = df1.hConcat(df2); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Concatenate this and another DataFrame horizontally. The argument is a vararg, so more than one DataFrame can be
passed to the method.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b a_ b_
- - -- --
1 2 5  6
3 4 7  8</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since both <code>df1</code> and <code>df2</code> had the same column names, and a DataFrame must only have unique columns, <code>_</code> suffix was
automatically appended to the conflicting columns in the resulting DataFrame. We will see this auto-renaming behavior
in other places, such as joins.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So far all our concatenation examples consisted of DataFrames that had matching dimensions (same number and names of
columns for <code>vConcat</code> and same number of rows for <code>hConcat</code>). But what if concatenated DataFrames are shaped or named
differently?</p>
</div>
<div class="paragraph">
<p>Concat methods may take an extra "how" parameter to define concatenation semantics. The type of the "how" parameter is
<code>JoinType</code>, and can be one of <code>inner</code> (default), <code>left</code>, <code>right</code>, <code>full</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We&#8217;ll see <code>JoinType</code> again soon when discussing <a href="#joins">joins</a>. Concatenation and joins are related fairly
closely.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s look how this works with <code>vConcat</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).of(
        <span class="integer">1</span>, <span class="integer">2</span>,
        <span class="integer">3</span>, <span class="integer">4</span>);

DataFrame df2 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>).of( <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="integer">5</span>, <span class="integer">6</span>,
        <span class="integer">7</span>, <span class="integer">8</span>);

DataFrame dfv = df1.vConcat(JoinType.inner, df2); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>df1</code> column names are "b" and "c", while <code>df2</code> - "a" and "c".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Explicitly passing <code>JoinType.inner</code> to <code>vConcat</code>. It is done to demonstrate the point. Since <code>inner</code> is the
default, omitting it will not change the outcome.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a
-
2
4
5
7</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the result, the behavior of <code>inner</code> join is to only keep columns that are present in both <code>df1</code> and
<code>df2</code>. Columns are joined by name, regardless of their order (though the order of columns is preserved in the result,
following the order in each DataFame being joined, left to right).</p>
</div>
<div class="paragraph">
<p>Changing semantics from <code>inner</code> to <code>left</code> gives us all the columns of the leftmost DataFrame, but those columns that
are missing from the concatenated DataFrame are filled with nulls in the corresponding positions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame dfv = df1.vConcat(JoinType.left, df2);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>b    a
---- -
1    2
3    4
null 5
null 7</pre>
</div>
</div>
<div class="paragraph">
<p>Leaving it as an exercise for the reader to try <code>right</code> and <code>full</code> joins.</p>
</div>
<div class="paragraph">
<p><code>hConcat</code> works similarly, however concatenation is done by row <em>position</em>, as there are no row names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).of(
        <span class="integer">1</span>, <span class="integer">2</span>,
        <span class="integer">3</span>, <span class="integer">4</span>,
        <span class="integer">5</span>, <span class="integer">6</span>);

DataFrame df2 = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">d</span><span class="delimiter">&quot;</span></span>).of(
        <span class="integer">7</span>, <span class="integer">8</span>,
        <span class="integer">9</span>, <span class="integer">10</span>);

DataFrame dfv = df1.hConcat(JoinType.left, df2);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>a b c    d
- - ---- ----
1 2 7    8
3 4 9    10
5 6 null null</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="joins">Joins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you worked with relational databases, you know what "joins" are. This is a way to combine related rows from
multiple tables. DataFrames can be joined together, just like two DB tables. DFLib provides 4 familiar flavors of joins:
<code>inner</code>, <code>left</code> (outer), <code>right</code> (outer) and <code>full</code> (outer).</p>
</div>
<div class="sect2">
<h3 id="_inner_joins">Inner Joins</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame left = DataFrame
        .foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
        .of(<span class="integer">1</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="integer">3</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>);

DataFrame right = DataFrame
        .foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>)
        .of(<span class="integer">2</span>, <span class="integer">25</span>, <span class="integer">3</span>, <span class="integer">59</span>, <span class="integer">4</span>, <span class="integer">40</span>);

DataFrame joined = left
        .join(right) <i class="conum" data-value="1"></i><b>(1)</b>
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>join(..)</code> is equivalent to <code>innerJoin(..)</code> (just like in SQL). With "inner" semantics, only the matching rows that
are present in both DataFrames will be included in the result below.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Columns used in the join criteria have the same name in both DataFrames, so we can specify the name of the join column
only once. In general, the names do not need to match, and multiple columns can participate in a join.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>id name    id_ age
-- ------- --- ---
 2 Juliana   2  25
 3 Joan      3  59</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_column_namespace">Column Namespace</h3>
<div class="paragraph">
<p>Notice how DFLib treated the <code>id</code> column in the join result above. Since it was present in both left and right DataFrames,
it was included in the result twice, but the second instance was renamed to <code>id_</code> to avoid a naming collision. The same
renaming would occur for any other columns from the right DataFrame that have conflicting names with the columns from
the left. A quick way to get rid of duplicate columns is to exclude them from the result using the name pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame joined = left
        .join(right)
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>)
        .colsExcept(c -&gt; c.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">_</span><span class="delimiter">&quot;</span></span>))
        .select();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>id name    age
-- ------- ---
 2 Juliana  25
 3 Joan     59</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may have noticed that <code>colsExcept(..).select()</code> style of picking join columns is very similar to the
<a href="#column_ops">column set API</a>. The main difference is that the <code>Join</code> object itself represents a special form of column
set, and only "select" operations are available.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For better clarity, you can assign names to the left and/or the right DataFrames just before the join, and the
column names in the result will be prefixed with the corresponding <code>DataFrame</code> name, thus avoiding the trailing underscore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame joined = left.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">L</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .join(right.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">R</span><span class="delimiter">&quot;</span></span>)) <i class="conum" data-value="2"></i><b>(2)</b>
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>)
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Assign the name to the left DataFrame</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Assign the name to the right DataFrame</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This makes it easier to identify the origin of each column.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>L.id L.name  R.id R.age
---- ------- ---- -----
   2 Juliana    2    25
   3 Joan       3    59</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DataFrame</code> immutability applies to name assignments as well. Calling <code>.as()</code> creates a separate
<code>DataFrame</code>, so the original one remains unnamed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_transform_columns">Transform Columns</h3>
<div class="paragraph">
<p>When building the join result, you can apply expressions to alter the existing columns or create new columns all
together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame joined = left.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">L</span><span class="delimiter">&quot;</span></span>)
        .join(right.as(<span class="string"><span class="delimiter">&quot;</span><span class="content">R</span><span class="delimiter">&quot;</span></span>))
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">retires_soon</span><span class="delimiter">&quot;</span></span>)
        .select(
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">R.age</span><span class="delimiter">&quot;</span></span>).gt(<span class="integer">57</span>)
        );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>name    retires_soon
------- ------------
Juliana        false
Joan            true</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the context of a join, column expressions can reference either short column names of left and right
DataFrames, or the fully qualified ones with the prefix. In the former case, the names should take into account  the "_"
suffix applied to the right <code>DataFrame</code> columns when their names overlap with column names on the left.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_outer_joins">Outer Joins</h3>
<div class="paragraph">
<p>Now let&#8217;s demonstrate outer joins. Here is a <code>leftJoin(..)</code> example using the same left and right DataFrames:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame joined = left
        .leftJoin(right)
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>)
        .select();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>id name     id_  age
-- ------- ---- ----
 1 Jerry   null null
 2 Juliana    2   25
 3 Joan       3   59</pre>
</div>
</div>
<div class="paragraph">
<p>It has all the rows from the left DataFrame, and only the matching rows from the right DataFrame. For left rows with no
matching right rows, the right columns are filled with <code>null</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_indicator_column">Indicator Column</h3>
<div class="paragraph">
<p>Join API allows to explicitly identify which rows had a match, and which didn&#8217;t by adding a special "indicator" column.
Let&#8217;s show it on a <code>fullJoin(..)</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame joined = left
        .fullJoin(right)
        .on(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>)
        .indicatorColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">join_type</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .colsExcept(c -&gt; c.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">_</span><span class="delimiter">&quot;</span></span>))
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Request an indicator column with a user-specified name.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>  id name     age join_type
---- ------- ---- ----------
   1 Jerry   null left_only
   2 Juliana   25 both
   3 Joan      59 both
null null      40 right_only</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>join_type</code> column will contain a special enum of <code>org.dflib.join.JoinIndicator</code> type that allows to categorize rows
in the produced DataFrame.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
indicator column can be requested for all join types, but it is only useful for the three outer joins (it will
always be <code>both</code> for inner joins).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_nested_loop_joins">Nested Loop Joins</h3>
<div class="paragraph">
<p>The joins we&#8217;ve seen so far were all based on comparing left and right column values. They are knows as "hash joins",
and are usually as fast as joins can get. However, they can not express every possible condition, and sometimes we have
to resort to another kind of joins - "nested loop", that would compare every row from the left DataFrame to every row
from the right. For instance, let&#8217;s join a DataFrame of salaries with itself to produce pairs of names - a person with
higher salary on the left vs. everyone with lower salary on the right:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="integer">120000</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana</span><span class="delimiter">&quot;</span></span>, <span class="integer">80000</span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">95000</span>);

JoinPredicate p = (r1, r2) -&gt;
        ((<span class="predefined-type">Integer</span>) r1.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)) &gt; ((<span class="predefined-type">Integer</span>) r2.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>));

DataFrame joined = df
        .leftJoin(df)
        .predicatedBy(p) <i class="conum" data-value="1"></i><b>(1)</b>
        .select()
        .sort(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).desc(), <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary_</span><span class="delimiter">&quot;</span></span>).desc()) <i class="conum" data-value="2"></i><b>(2)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name_</span><span class="delimiter">&quot;</span></span>).selectAs(<span class="string"><span class="delimiter">&quot;</span><span class="content">makes_more</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">makes_less</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Custom join condition</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Sorting and renaming the result columns for a user-friendly display</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>makes_more makes_less
---------- ----------
Jerry      Joan
Jerry      Juliana
Joan       Juliana
Juliana    null</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nested loop joins are <em>much</em> slower, and should be avoided unless absolutely necessary.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="group_aggregate">Group and Aggregate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DataFrame rows can be combined into groups based on common column values. For instance, here is a payroll report
that contains payments to employees over time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name             amount date
---------------- ------ ----------
Jerry Cosin        8000 2024-01-15
Juliana Walewski   8500 2024-01-15
Joan O'Hara        9300 2024-01-15
Jerry Cosin        4000 2024-02-15
Juliana Walewski   8500 2024-02-15
Joan O'Hara        9300 2024-02-15
Jerry Cosin        8000 2024-03-15
Joan O'Hara        9300 2024-03-15</pre>
</div>
</div>
<div class="paragraph">
<p>We can group it by date like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">GroupBy groupBy = df.group(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Here we are grouping by a single column, but multiple columns can be specified as well</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>GroupBy</code> object has a number of useful operations to transform grouped data. The most common one is aggregation of
values to produce one row per group (similar to SQL <code>GROUP BY</code> clause). E.g., we can calculate some statistics about
each payroll period by passing a list of "aggregating" expressions to the <code>agg(..)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame agg = df
        .group(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>)
        .agg(
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>).first(), <i class="conum" data-value="1"></i><b>(1)</b>
                <span class="error">$</span><span class="type">double</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">amount</span><span class="delimiter">&quot;</span></span>).sum(), <i class="conum" data-value="2"></i><b>(2)</b>
                count() <i class="conum" data-value="3"></i><b>(3)</b>
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>first(..)</code> expression is applied to the column used in the grouping. As each value within the group is the same,
we can simply select the first one for our aggregated row</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This calculates total payroll amount within each group</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>count()</code> returns the number of rows in each group</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>date       sum(amount) count
---------- ----------- -----
2024-01-15     25800.0     3
2024-02-15     21800.0     3
2024-03-15     17300.0     2</pre>
</div>
</div>
<div class="paragraph">
<p><code>first(..)</code>, <code>sum(..)</code> and <code>count()</code> are special "aggregating" expressions. Unlike the "normal" expressions that produce
Series of the same size as input Series, aggregating ones output Series with single values. Hence,
the number of rows in the aggregated DataFrame is equal to the number of groups in <code>GroupBy</code>. There are more aggregating
expressions that can concatenate values within a group, calculate min, max, avg values, etc.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s make a minor improvement to the example above and provide more descriptive column names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame agg = df
        .group(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">employees</span><span class="delimiter">&quot;</span></span>)
        .agg(
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>).first(),
                <span class="error">$</span><span class="type">double</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">amount</span><span class="delimiter">&quot;</span></span>).sum(),
                count()
        );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>date         total employees
---------- ------- ---------
2024-01-15 25800.0         3
2024-02-15 21800.0         3
2024-03-15 17300.0         2</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There&#8217;s a similarity between <code>GroupBy.cols(..)</code> method and <code>DataFrame.cols(..)</code>. And, as we&#8217;ll see in the later
examples, a few more methods (<code>select(..)</code> and  <code>map(..)</code>) work the same as in <code>ColumnSet</code>. So <code>GroupBy</code> is essentially
a <code>ColumnSet</code> with operations applied per group.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Instead of aggregating groups, we can select back the original rows, but apply some group-specific transformations.
E.g. we can do row ranking within groups. Here we&#8217;ll rank employees by their salary amount vs other employees
in the same period:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame ranked = df.group(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>)
        .sort(<span class="error">$</span><span class="type">double</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">amount</span><span class="delimiter">&quot;</span></span>).desc()) <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">rank</span><span class="delimiter">&quot;</span></span>)
        .select( <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>),
                <span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>),
                rowNum() <i class="conum" data-value="3"></i><b>(3)</b>
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>To produce a proper ranking, we need to order rows within each group first</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In <code>select(..)</code>, instead of aggregating expressions, we are using "normal" ones , but they are applied to
each group separately.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Ranking function applied within each group</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>date       name             rank
---------- ---------------- ----
2024-01-15 Joan O'Hara         1
2024-01-15 Juliana Walewski    2
2024-01-15 Jerry Cosin         3
2024-02-15 Joan O'Hara         1
2024-02-15 Juliana Walewski    2
2024-02-15 Jerry Cosin         3
2024-03-15 Joan O'Hara         1
2024-03-15 Jerry Cosin         2</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting DataFrame has the same number of rows as the original one, but the ordering is different, and the columns
are the ones that we requested.</p>
</div>
<div class="paragraph">
<p>We can use <code>GroupBy.head(..)</code> and (<code>tail(..)</code>) to find top-paid employees within each payroll period. Notice,
that this operation doesn&#8217;t do any aggregation. Just sorting within groups and picking the top results:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame topSalary = df.group(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>)
        .sort(<span class="error">$</span><span class="type">double</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">amount</span><span class="delimiter">&quot;</span></span>).desc()) <i class="conum" data-value="1"></i><b>(1)</b>
        .head(<span class="integer">1</span>) <i class="conum" data-value="2"></i><b>(2)</b>
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Do the same sorting as before</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pick the top row in each group</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name        amount date
----------- ------ ----------
Joan O'Hara   9300 2024-01-15
Joan O'Hara   9300 2024-02-15
Joan O'Hara   9300 2024-03-15</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="window">Window Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Window operations are somewhat close to "group", except they usually preserve the rows of the original
<code>DataFrame</code> and may add extra columns with values calculated from "windows" of data relative to a given row. We&#8217;ll use
the following <code>DataFrame</code> with company salary history to demonstrate how window operations work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary date
---------------- ------ ----------
Jerry Cosin       88000 2024-01-15
Juliana Walewski  85000 2024-01-15
Joan O'Hara       93000 2024-01-15
Jerry Cosin       95000 2024-12-15
Juliana Walewski  85000 2025-02-15
Joan O'Hara       80000 2023-01-01
Joan O'Hara       78000 2022-01-01</pre>
</div>
</div>
<div class="paragraph">
<p>A window is created by calling <code>over()</code> on the <code>DataFrame</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Window</span> window = df.over();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a full operation that adds a "max_salary" column to each employee:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .over()
        .partitioned(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">max_salary</span><span class="delimiter">&quot;</span></span>).merge(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).max()); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines optional DataFrame "partitioning". Calculation window for each row will be all the rows in the same partition.
If no partition is defined, the entire DataFrame is treated as a single partition.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines a new column and an expression to produce values.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary date       max_salary
---------------- ------ ---------- ----------
Jerry Cosin       88000 2024-01-15      95000
Juliana Walewski  85000 2024-01-15      85000
Joan O'Hara       93000 2024-01-15      93000
Jerry Cosin       95000 2024-12-15      95000
Juliana Walewski  85000 2025-02-15      85000
Joan O'Hara       80000 2023-01-01      93000
Joan O'Hara       78000 2022-01-01      93000</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>max()</code> expression used above is "aggregating", so it resulted in the same max salary value in each position for a
given person. But Window expressions don&#8217;t have to be aggregating. They can assign numbers to rows in a partition,
calculate a cumulative sum, etc. For that second type of expressions, the order of rows within a partition is important,
so <code>Window</code> object defines a <code>sort(..)</code> operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .over()
        .partitioned(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
        .sorted(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>).asc()) <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">raises_to_date</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">raise_amount</span><span class="delimiter">&quot;</span></span>).merge(
                rowNum().sub(<span class="integer">1</span>), <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).sub(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).shift(<span class="integer">1</span>)) <i class="conum" data-value="3"></i><b>(3)</b>
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sorts each partition by date before applying operations</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Applying <code>rowNum()</code> to calculate how many salary changes a person had already as of a given raise</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Calculate a raise amount by subtracting the new salary from the previous salary</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary date       raises_to_date raise_amount
---------------- ------ ---------- -------------- ------------
Jerry Cosin       88000 2024-01-15              0         null
Juliana Walewski  85000 2024-01-15              0         null
Joan O'Hara       93000 2024-01-15              2        13000
Jerry Cosin       95000 2024-12-15              1         7000
Juliana Walewski  85000 2025-02-15              1            0
Joan O'Hara       80000 2023-01-01              1         2000
Joan O'Hara       78000 2022-01-01              0         null</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, the ordering of preceding rows was required to calculate both <code>raises_to_date</code> and <code>raise_amount</code> columns.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Sorting within the Window does not affect the sort order of the result, it is only calculated internally for the
sake of the column operations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Partitioning in the example above is similar to "group" in <code>GroupBy</code>. Another way to define a window span is via the
<code>range(..)</code> method that allows to build window with fixed offset relative to each row:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df1 = df
        .over()
        .partitioned(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
        .sorted(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>).asc())
        .range(WindowRange.allPreceding)  <i class="conum" data-value="1"></i><b>(1)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">history_to_date</span><span class="delimiter">&quot;</span></span>).merge(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).vConcat(<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specifies a dynamic partition range as all rows from 0 to the current row</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lists all salaries to date a given record</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary date       history_to_date
---------------- ------ ---------- -------------------
Jerry Cosin       88000 2024-01-15 88000
Juliana Walewski  85000 2024-01-15 85000
Joan O'Hara       93000 2024-01-15 78000, 80000, 93000
Jerry Cosin       95000 2024-12-15 88000, 95000
Juliana Walewski  85000 2025-02-15 85000, 85000
Joan O'Hara       80000 2023-01-01 78000, 80000
Joan O'Hara       78000 2022-01-01 78000</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, specifying a range is usually combined with sorting. In addition to standard ranges (
<code>WindowRange.allPreceding</code>, <code>WindowRange.allFollowing</code>, <code>WindowRange.all</code>), you can specify a range as a pair of
offsets in both directions to create a sliding window. E.g., <code>WindowRange.of(2, 2)</code>.</p>
</div>
<div class="sect2">
<h3 id="_row_ranking">Row Ranking</h3>
<div class="paragraph">
<p>"Ranking" means assigning a numeric value to a row in a <code>DataFrame</code> based on some sorting criteria. E.g., countries can
be ranked by their average life expectancy, sports teams can be ranked by how many points they have, etc.</p>
</div>
<div class="paragraph">
<p>One form of ranking is assigning sequential numbers to each row in a sorted <code>Window</code>. We&#8217;ve seen the examples
of it above (<code>rowNum()</code> expression). With this approach, each row will have a unique number. It is somewhat simplistic,
as it doesn&#8217;t take <em>ties</em> into account (i.e. two or more rows being equivalent from the point of view of the sorting
criterion). To do ranking with ties, <code>Windows</code> offers two operations - <code>rank()</code> and <code>denseRank()</code>.</p>
</div>
<div class="paragraph">
<p>For this chapter, let&#8217;s use the following <code>DataFrame</code> with only the current salaries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary
---------------- ------
Jerry Cosin       88000
Paul Austin       93000
Juliana Walewski  85000
Joan O'Hara       93000</pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s calculate their rank:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">IntSeries ranks = df
        .over()
        .sorted(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).desc()) <i class="conum" data-value="1"></i><b>(1)</b>
        .rank(); <i class="conum" data-value="2"></i><b>(2)</b>

DataFrame df1 = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">rank</span><span class="delimiter">&quot;</span></span>).merge(ranks); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Sorting is essential for ranking, unless the <code>DataFrame</code> is already sorted in the desired order</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Calculate ranking as an <code>IntSeries</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Add ranking back to the <code>DataFrame</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary rank
---------------- ------ ----
Jerry Cosin       88000    3
Paul Austin       93000    1
Juliana Walewski  85000    4
Joan O'Hara       93000    1</pre>
</div>
</div>
<div class="paragraph">
<p>People with the same salary now have the same rank. Also, the ranking is "sparse" - notice that the rank of "2" is
missing. The logic behind it is that there are two rows tied for the rank of "1".
So the row following them takes the third spot, and should be ranked as "3". To avoid tie-related gaps, there is a similar
operation called <code>denseRank()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">IntSeries ranks = df
        .over()
        .sorted(<span class="error">$</span><span class="type">int</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).desc())
        .denseRank(); <i class="conum" data-value="1"></i><b>(1)</b>

DataFrame df1 = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">dense_rank</span><span class="delimiter">&quot;</span></span>).merge(ranks);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of <code>rank()</code>, calculate a <code>denseRank()</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>name             salary dense_rank
---------------- ------ ----------
Jerry Cosin       88000          2
Paul Austin       93000          1
Juliana Walewski  85000          3
Joan O'Hara       93000          1</pre>
</div>
</div>
<div class="paragraph">
<p>Here the ranking is the same, except there are no gaps.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike <code>rowNum()</code> expression, there are currently no expressions for either <code>rank()</code> or <code>denseRank()</code>.
So you need to calculate a rank an <code>IntSeries</code> first and then add it back to the <code>DataFrame</code>. This is due to the semantics
of the ranking operations that requires the knowledge of <code>Window</code> sorting. This is a minor inconvenience, and we&#8217;ll
try to eliminate it in the future.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pivot">Pivot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stack">Stack</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="udfs">User-Defined Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>User-defined functions (aka "UDF") is a way to create highly-reusable expressions. <a href="#expressions">Expressions</a> are,
of course, abstract transformations of columns, so they are already somewhat reusable. However, they encode names
(or positions) of all columns they operate on. So you won&#8217;t be able to apply the same expression to two different sets
of columns in the same DataFrame. UDFs are intended to address this limitation and make expressions fully dynamic.</p>
</div>
<div class="paragraph">
<p>As the name implies, a UDF is a function (usually implemented as a lambda or a method ref). It takes one or more
expressions as parameters, and produces a single expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> formatNames() {
    DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).of(
            <span class="string"><span class="delimiter">&quot;</span><span class="content">JERRY</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">COSIN</span><span class="delimiter">&quot;</span></span>,
            <span class="string"><span class="delimiter">&quot;</span><span class="content">juliana</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">waLEwsKi</span><span class="delimiter">&quot;</span></span>);

    Udf1&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; formatName = e -&gt;
            e.castAsStr().mapVal(<span class="local-variable">this</span>::formatName); <i class="conum" data-value="1"></i><b>(1)</b>

    DataFrame clean = df.cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).merge(
            formatName.call(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>),
            formatName.call(<span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b>
}

<span class="predefined-type">String</span> formatName(<span class="predefined-type">String</span> raw) {
    <span class="keyword">return</span> <span class="predefined-type">Character</span>.toUpperCase(raw.charAt(<span class="integer">0</span>))
            + raw.substring(<span class="integer">1</span>).toLowerCase();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define a UDF that takes a single parameter and performs proper name capitalization</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Apply the same UDF separately to the "first" and "last" name columns</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first   last
------- --------
Jerry   Cosin
Juliana Walewski</pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we called the UDF multiple times, each time with a different column name. A UDF can also
be invoked with a numeric position or a full expression instead of a column name.</p>
</div>
<div class="paragraph">
<p>Above, we used <code>Udf1</code> function, that takes only one expression (or column) as an input. Generally, UDFs can take
any number of expressions (columns). There are <code>Udf1</code>, <code>Udf2</code>, <code>Udf3</code> and <code>UdfN</code> interfaces. The latter can take any
number of arguments and should be used to model UDFs with more than 3 inputs or a variable number of inputs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).of(
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Cosin</span><span class="delimiter">&quot;</span></span>,
        <span class="predefined-constant">null</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Walewski</span><span class="delimiter">&quot;</span></span>,
        <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>);

UdfN&lt;<span class="predefined-type">Boolean</span>&gt; noNulls = exps -&gt; and( <i class="conum" data-value="1"></i><b>(1)</b>
        Stream.of(exps)
                .map(Exp::isNotNull)
                .toArray(<span class="predefined-type">Condition</span><span class="type">[]</span>::<span class="keyword">new</span>)
);

DataFrame clean = df
        .rows(noNulls.call(<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>).castAsBool()) <i class="conum" data-value="2"></i><b>(2)</b>
        .select();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Build a UDF with dynamic number of input parameters packaged in the <code>Exp[]</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Call the UDF to create a row filter. Since the UDF return type is <code>Exp&lt;Boolean&gt;</code>,
we need to explicitly "cast" it to <code>Condition</code> expected by the <code>RowSet</code>, so we used  <code>castAsBool()</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>first last
----- -----
Jerry Cosin</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Performance hint: If the logic within a UDF requires converting a column to a specific data type,
and the column you are applying it to is known to be of that type already, you can speed up evaluation
by passing an expression of that type to the UDF. E.g. if a UDF calls <code>castAsInt()</code> on its argument,
<code>udf.call($int("a"))</code> is much faster than <code>udf.call("a")</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jdbc">Using Relational Databases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Relational databases are arguably the most important type of data stores out there. Also they happen to map
really well to DataFrames. DFLib provides advanced support for loading and saving DataFrames to RDBMS. It supports
transactions, auto-generation of certain SQL statements, merging of data on top of the existing data
("create-or-update"), building custom SQL for selects and updates. It knows how to treat different DB
"flavors" and does a number of other cool database-related things.</p>
</div>
<div class="paragraph">
<p>To start using all this, you need to import <code>dflib-jdbc</code> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-jdbc<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span>

<span class="comment">&lt;!-- Additionally, you need to import your JDBC driver --&gt;</span>
<span class="tag">&lt;dependency&gt;</span> ... <span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_jdbcconnector">JdbcConnector</h3>
<div class="paragraph">
<p>Once the imports are set up, you&#8217;d use <code>Jdbc</code> class to create an instance of <code>JdbcConnector</code> that will be used for
all DB operations. You may already have a preconfigured <code>javax.sql.DataSource</code>, so the simplest way to create a
connector is to pass that DataSource to <code>Jdbc</code> factory method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">JdbcConnector connector = Jdbc.connector(dataSource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can specify the connection information directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">JdbcConnector connector = Jdbc
        .connector(<span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:derby:target/derby/mydb;create=true</span><span class="delimiter">&quot;</span></span>)
        <span class="comment">// .driver(&quot;com.foo.MyDriver&quot;) </span><i class="conum" data-value="1"></i><b>(1)</b>
        <span class="comment">// .userName(&quot;root&quot;)</span>
        <span class="comment">// .password(&quot;secret&quot;) </span><i class="conum" data-value="2"></i><b>(2)</b>
        .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(Optional) Driver name. Some drivers are not packaged in a JDBC-compliant manner, and require an explicit declaration.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>DB account username/password (not needed for our in-memory Derby example, but will definitely be required for a real database).</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_tableloader_tablesaver">TableLoader / TableSaver</h3>
<div class="paragraph">
<p>Once you have the connector, you can start reading and persisting <code>DataFrame</code> data. A <code>DataFrame</code> can map directly to
a single table (or a view) from the database. If that&#8217;s the case, DFLib provides a set of rather straightforward
operations that do not require the user to write SQL (SQL is auto-generated by the framework):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = connector.tableLoader(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).load();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>id name              salary
-- ----------------- --------
 1 Jerry Cosin       70000.0
 2 Juliana Walewski  85000.0
 3 Joan O'Hara       101000.0</pre>
</div>
</div>
<div class="paragraph">
<p>Table loader provides a way to customize the load operation. It allows to select specific columns, set the maximum
number of rows to read, sample rows, and even specify fetch condition as another DataFrame. Some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame condition = DataFrame
        .byColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)
        .of(Series.ofInt(<span class="integer">70</span>_000, <span class="integer">101</span>_000));

DataFrame df = connector.tableLoader(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)
        .eq(condition)
        .load();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>name        salary
----------- --------
Jerry Cosin 70000.0
Joan O'Hara 101000.0</pre>
</div>
</div>
<div class="paragraph">
<p>What it doesn&#8217;t require (unlike <a href="#csv">CSV loader</a>) is explicit column types, as the proper value types are inferred
from the database metadata.</p>
</div>
<div class="paragraph">
<p>Table saver allows to save DataFrame to a table. Column names in the DataFrame should match column names in the DB table:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.byArrayRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)
        .appender()
        .append(<span class="integer">1</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry Cosin</span><span class="delimiter">&quot;</span></span>, <span class="integer">70</span>_000)
        .append(<span class="integer">2</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana Walewski</span><span class="delimiter">&quot;</span></span>, <span class="integer">85</span>_000)
        .append(<span class="integer">3</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="integer">101</span>_000)
        .toDataFrame();

connector.tableSaver(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).save(df);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this scenario table saver executes insert for each DataFrame row. But what if there is already an existing data
in the table? There are a few options the user has to overwrite or merge the data:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Append the data (that&#8217;s what we effectively did above).</p>
</li>
<li>
<p>Delete all existing data before doing the insert.</p>
</li>
<li>
<p>Merge the data by comparing DataFrame and DB table data on PK column(s) or an arbitrary set of columns. Insert missing
rows, update the existing rows. If the table has more columns than there are columns in the DataFrame, the data in those
extra columns is preserved.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Delete before insert example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">connector.tableSaver(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>)
        .deleteTableData()
        .save(df);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Merge by PK example (PK columns are detected from DB metadata) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">connector.tableSaver(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>)
        .mergeByPk()
        .save(df);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sqlloader_sqlsaver">SqlLoader / SqlSaver</h3>
<div class="paragraph">
<p>If your data has complex filtering conditions, spans more than one table or otherwise requires a customized
query, <code>TableLoader</code> can not be used. The alternative is to write your own SQL and execute it via <code>SqlLoader</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = connector.sqlLoader(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        select </span><span class="delimiter">&quot;</span></span>name<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>city<span class="string"><span class="delimiter">&quot;</span><span class="content">
          from </span><span class="delimiter">&quot;</span></span>person<span class="string"><span class="delimiter">&quot;</span><span class="content"> p
          left join </span><span class="delimiter">&quot;</span></span>address<span class="string"><span class="delimiter">&quot;</span><span class="content"> a on (p.</span><span class="delimiter">&quot;</span></span>id<span class="string"><span class="delimiter">&quot;</span><span class="content"> = a.</span><span class="delimiter">&quot;</span></span>person_id<span class="string"><span class="delimiter">&quot;</span><span class="content">)
          where </span><span class="delimiter">&quot;</span></span>salary<span class="string"><span class="delimiter">&quot;</span><span class="content"> &gt; 80000
          order by </span><span class="delimiter">&quot;</span></span>name<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>city<span class="string"><span class="delimiter">&quot;</span><span class="content">
          </span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).load();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>name             city
---------------- ------
Joan O'Hara      Minsk
Joan O'Hara      Warsaw
Juliana Walewski London</pre>
</div>
</div>
<div class="paragraph">
<p><code>80000</code> value is hardcoded in the example above. We can make it a dynamic parameter, replacing it in the SQL with a
<code>?</code> sign and passing the value in the <code>.load(..)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = connector.sqlLoader(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        select </span><span class="delimiter">&quot;</span></span>name<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>city<span class="string"><span class="delimiter">&quot;</span><span class="content">
          from </span><span class="delimiter">&quot;</span></span>person<span class="string"><span class="delimiter">&quot;</span><span class="content"> p
          left join </span><span class="delimiter">&quot;</span></span>address<span class="string"><span class="delimiter">&quot;</span><span class="content"> a on (p.</span><span class="delimiter">&quot;</span></span>id<span class="string"><span class="delimiter">&quot;</span><span class="content"> = a.</span><span class="delimiter">&quot;</span></span>person_id<span class="string"><span class="delimiter">&quot;</span><span class="content">)
          where </span><span class="delimiter">&quot;</span></span>salary<span class="string"><span class="delimiter">&quot;</span><span class="content"> &gt; ?
          order by </span><span class="delimiter">&quot;</span></span>name<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>city<span class="string"><span class="delimiter">&quot;</span><span class="content">
          </span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).load(<span class="integer">80000</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>A few things to note here. The SQL String is written in a format of <code>java.sql.PreparedStatement</code>. So, <code>?</code> placeholders
denote dynamic parameters. Parameters are positional (each <code>?</code> position is matched with a value at that position in the
<code>load(..)</code> argument). Parameters can only be values, you can&#8217;t pass pieces of SQL as parameters. This is a
<code>PreparedStatement</code> behavior that prevents SQL injection attacks.</p>
</div>
<div class="paragraph">
<p>Similarly, to save data with custom SQL, you would use <code>SqlSaver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.byArrayRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)
        .appender()
        .append(<span class="integer">1</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jerry Cosin</span><span class="delimiter">&quot;</span></span>, <span class="integer">70</span>_000)
        .append(<span class="integer">2</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Juliana Walewski</span><span class="delimiter">&quot;</span></span>, <span class="integer">85</span>_000)
        .append(<span class="integer">3</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Joan O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="integer">101</span>_000)
        .toDataFrame();

connector.sqlSaver(<span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        insert into </span><span class="delimiter">&quot;</span></span>person<span class="string"><span class="delimiter">&quot;</span><span class="content"> values (?, ?, ?)
        </span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).save(df);</code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL parameters should match a "row" in the <code>.save(..)</code> argument. If the argument is a <code>Series</code> or an <code>Object[]</code>,
it is treated as a single row of values, and will be bound to the prepared statement parameters by position. If the
argument is a <code>DataFrame</code>, the statement will be executed multiple times, once per each row.</p>
</div>
<div class="paragraph">
<p>DFLib code contains some JDBC-level
batching optimizations transparent to the user, that make the latter work faster, still the result you&#8217;d
observe would look as if you ran the SQL n times, where "n" is the height of the <code>DataFrame</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="csv">CSV Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>CSV (comma-separated values) is a very common and rather simple format for working with raw data. <code>*.csv</code> files can be
manipulated programmatically or manually (via Excel/LibreOffice), loaded to / from databases, etc. DFLib supports
reading DataFrames from CSV and storing them to CSV. You need to add an extra dependency to your project to take
advantage of this functionality:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-csv<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you do that, <code>Csv</code> class is the entry point to all the <code>.csv</code> related operations as discussed below.</p>
</div>
<div class="sect2">
<h3 id="_reading_csv">Reading CSV</h3>
<div class="paragraph">
<p>The simplest way to create a <code>DataFrame</code> from a CSV file is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = Csv.load(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/test/resources/f1.csv</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The argument to the "load" method can be a filename, a file, or a Reader, so it can be loaded from a variety of
sources.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The result is a DataFrame that matches the CSV structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>A B
- --
1 s1
4 s2</pre>
</div>
</div>
<div class="paragraph">
<p>DFLib made a few assumptions about the data in <code>f1.csv</code>, namely that the first row represents
column names, that all columns are Strings, and that all of them need to be included. These assumptions are not
necessarily true with many data sets. So there is a longer form of this API that allows to configure column types,
skip rows and columns, or even sample the data without loading the entire CSV in memory. Some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = Csv.loader() <i class="conum" data-value="1"></i><b>(1)</b>
        .offset(<span class="integer">1</span>) <i class="conum" data-value="2"></i><b>(2)</b>
        .header(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">y</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="3"></i><b>(3)</b>
        .intCol(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="4"></i><b>(4)</b>
        .load(<span class="string"><span class="delimiter">&quot;</span><span class="content">src/test/resources/f1.csv</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of "load" method use "loader".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Skip the header row.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Provide our own header.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Convert the first column to int.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>x y
- --
1 s1
4 s2</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In theory, you don&#8217;t have to do most of these tweaks via CSV loader. You can load the raw data, and then use
standard DataFrame transformations to shape the result. However, doing it via the loader allows to optimize
both load speed and memory use, so it is usually preferable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The examples above showed how to read a CSV from a local file using a String file name. Instead of a String name, you can
also pass <code>java.nio.file.Path</code> or <code>java.io.File</code> objects. More generally, you can read a CSV from a URL or any other
source representable as <code>ByteSource</code> or <code>ByteSources</code> (see <a href="#bin_data_sources">"Binary Data Sources" chapter</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_writing_csv">Writing CSV</h3>
<div class="paragraph">
<p>Writing to a CSV is equally easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Csv.save(df, <span class="string"><span class="delimiter">&quot;</span><span class="content">target/df.csv</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The argument to the "save" method can be a filename, a file, a Writer (or generally Appendable), so it can be stored
to a variety of destinations.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just like with the loader, CSV saver provides its own set of options, if the defaults are not sufficient:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Csv.saver() <i class="conum" data-value="1"></i><b>(1)</b>
        .createMissingDirs() <i class="conum" data-value="2"></i><b>(2)</b>
        .format(CSVFormat.EXCEL) <i class="conum" data-value="3"></i><b>(3)</b>
        .save(df, <span class="string"><span class="delimiter">&quot;</span><span class="content">target/csv/df.csv</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instead of "save" method use "saver" to be able to customize the process.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If intermediate directories for the output file are missing, create them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Provide an alternative format (either from a collection of known formats, or user-specific).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="excel">Excel Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Excel format is very common in the business and finance world. DFLib supports reading DataFrames from and storing
them to Excel. You need to add an extra dependency to your project to take
advantage of this functionality:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-excel<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="avro">Avro Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Avro binary format is common in data engineering. Its main advantage is that <code>.avro</code> files are saved with
an embedded schema. So when they are read back, the fields are converted to the correct Java types. This is different
from CSV, as reading a <code>.csv</code> by default produces a DataFrame with all String columns. To work with the Avro format,
include the following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-avro<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you do that, <code>Avro</code> class is the entry point to all the operations. With it you can save DataFrames to <code>.avro</code>
files and load them back.</p>
</div>
<div class="sect2">
<h3 id="_avro_schema">Avro Schema</h3>
<div class="paragraph">
<p>In most cases you don&#8217;t need to know anything about Avro schemas. DFLib automatically generates a schema for a
DataFrame before it is saved. Alternatively you can create a custom <code>Schema</code> object based on
<a href="https://avro.apache.org/docs/current/spec.html">Avro specification</a> and pass it to <code>AvroSaver</code>.</p>
</div>
<div class="paragraph">
<p>TODO&#8230;&#8203;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parquet">Parquet Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parquet is a popular columnar binary data format. Like, <code>.avro</code>, <code>.parquet</code> files are saved with
an embedded schema. So when they are read back, the fields are converted to the correct Java types.
To work with the Parquet format, include the following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-parquet<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you do that, <code>Parquet</code> class is the entry point to all the operations. With it you can save DataFrames to <code>.parquet</code>
files and load them back.</p>
</div>
<div class="paragraph">
<p>TODO&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="json">JSON Format</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DFLib provides JSON load and save operations. To start, add the following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-json<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>From here, <code>Json</code> class is the entry point to both operations.</p>
</div>
<div class="sect2">
<h3 id="_reading_json">Reading JSON</h3>
<div class="paragraph">
<p>JSON is used to model nested tree-like data structures, whereas <code>DataFrame</code> is a flat table. So to load JSON to a table,
some kind of "flattening" conversion is needed. DFLib <code>JsonLoader</code> uses
<a href="https://www.rfc-editor.org/rfc/rfc9535">JSONPath query language</a> to "navigate" the JSON tree and map parts of its
data to <code>DataFrame</code> columns. But first let&#8217;s look how JSON inputs are interpreted without an explicit mapping.</p>
</div>
<div class="sect3">
<h4 id="_default_json_mapping">Default JSON Mapping</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If JSON root is a <em>list</em>, each list element is converted into a row of the result <code>DataFrame</code>. For each element:</p>
<div class="ulist">
<ul>
<li>
<p>if it is a scalar, its value is placed in a special cell called <code>_val</code></p>
</li>
<li>
<p>if it is an object, each object property is placed in a column matching this property name. The objects in the list
do not all have to have the same properties. The resulting <code>DataFrame</code> columns will be a "union" of all properties
encountered in the list.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        [
            5,
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:2, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S2<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S3<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:3, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S4<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>d<span class="string"><span class="delimiter">&quot;</span><span class="content">:false }
        ]</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .load(json);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>_val    a b    c        d
---- ---- ---- ---- -----
   5 null null null  null
null    1 S1   null  null
null    2 S2   S3    null
null    3 null S4   false</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike <code>CsvLoader</code>, a String argument for <code>JsonLoader.load(..)</code> method is interpreted as JSON body, not a
file name. These APIs will likely be better unified in the future versions.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>If JSON root is an <em>object</em>, then each of its properties is treated as a row. Property values are handled the same
way as list elements in the previous example - scalars are placed in <code>_val</code>, and property names are converted into
columns:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        {
            </span><span class="delimiter">&quot;</span></span>p1<span class="string"><span class="delimiter">&quot;</span><span class="content"> : 5,
            </span><span class="delimiter">&quot;</span></span>p2<span class="string"><span class="delimiter">&quot;</span><span class="content"> : { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            </span><span class="delimiter">&quot;</span></span>p3<span class="string"><span class="delimiter">&quot;</span><span class="content"> : { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:2, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S2<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S3<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            </span><span class="delimiter">&quot;</span></span>p4<span class="string"><span class="delimiter">&quot;</span><span class="content"> : { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:3, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S4<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>d<span class="string"><span class="delimiter">&quot;</span><span class="content">:false }
        }</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .load(json);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same exact <code>DataFrame</code> as in the first example is produced:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>_val    a b    c        d
---- ---- ---- ---- -----
   5 null null null  null
null    1 S1   null  null
null    2 S2   S3    null
null    3 null S4   false</pre>
</div>
</div>
</li>
<li>
<p>If the cell values are not scalars, but are themselves JSON lists or objects, they are converted to Java <code>List</code> and
<code>Map</code> instances:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Function&lt;<span class="predefined-type">Object</span>, <span class="predefined-type">String</span>&gt; labeler = o -&gt; <span class="keyword">switch</span> (o) { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">case</span> <span class="predefined-type">List</span> l -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">list</span><span class="delimiter">&quot;</span></span>;
    <span class="keyword">case</span> <span class="predefined-type">Map</span> m -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">map</span><span class="delimiter">&quot;</span></span>;
    <span class="keyword">default</span> -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">scalar</span><span class="delimiter">&quot;</span></span>;
};

<span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        [
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">: [1,2,3]   },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">: {</span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:4, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:5} },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">: {</span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:[6,7]} }
        ]</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .load(json)
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">L1</span><span class="delimiter">&quot;</span></span>).merge(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).mapVal(labeler))  <i class="conum" data-value="2"></i><b>(2)</b>
        .cols(<span class="string"><span class="delimiter">&quot;</span><span class="content">L2</span><span class="delimiter">&quot;</span></span>).merge(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).mapVal(o -&gt; <span class="keyword">switch</span> (o) {  <i class="conum" data-value="3"></i><b>(3)</b>
            <span class="keyword">case</span> <span class="predefined-type">List</span> l -&gt; labeler.apply(l.get(<span class="integer">0</span>));
            <span class="keyword">case</span> <span class="predefined-type">Map</span> m -&gt; labeler.apply(m.values().iterator().next());
            <span class="keyword">default</span> -&gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">scalar</span><span class="delimiter">&quot;</span></span>;
        }));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A function to help us analyze the result values</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Checking the type of values in column <code>a</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Checking the type of values in column <code>a</code> collections</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a          L1   L2
---------- ---- ------
[1,2,3]    list scalar
{b=4, c=5} map  scalar
{b=[6,7]}  map  list</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_json_mapping_with_jsonpath">JSON Mapping with JSONPath</h4>
<div class="paragraph">
<p>JSONPath is a <a href="https://www.rfc-editor.org/rfc/rfc9535">recently standardized</a> query language to navigate through JSON
and select its elements. It can help greatly in parsing deeply-nested JSON structures and extracting only the relevant data.
<code>JsonLoader</code> accepts a single optional JSONPath expression.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default implicit expression is <code>$.*</code> which means <em>"select all children of the root node"</em>. All
the examples above behaved as if this expression was specified.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some examples of using JSONPath:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Read the root JSON object as a single row</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
       { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> }</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .pathExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">$</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .load(json);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>JSONPath of <code>$</code> selects the root node</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b
- --
1 S1</pre>
</div>
</div>
</li>
<li>
<p>Read only a few specific properties of the root&#8217;s children</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        [
            5,
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:2, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S2<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S3<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:3, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S4<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>d<span class="string"><span class="delimiter">&quot;</span><span class="content">:false }
        ]</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .pathExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">$..['a','b']</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .load(json);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Selects properties <code>a</code> and <code>b</code></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b
- --
1 S1
2 S2</pre>
</div>
</div>
</li>
<li>
<p>Include objects with missing properties. Notice that the first and the last elements from the source JSON list in
the previous example were excluded from the result. The first was a scalar that doesn&#8217;t have either <code>a</code> or <code>b</code>
property, and the last - an object with <code>a</code>, but without the <code>b</code> property. This is the intended default behavior of
this JSONPath query, and it can be partially altered via <code>JsonLoader.nullsForMissingLeafs()</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        [
            5,
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:2, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S2<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S3<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
            { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:3, </span><span class="delimiter">&quot;</span></span>c<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S4<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>d<span class="string"><span class="delimiter">&quot;</span><span class="content">:false }
        ]</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .pathExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">$..['a','b']</span><span class="delimiter">&quot;</span></span>)
        .nullsForMissingLeafs() <i class="conum" data-value="1"></i><b>(1)</b>
        .load(json);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The object with no <code>a</code> or <code>b</code> property is included, but the scalar value is still excluded</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b
- ----
1 S1
2 S2
3 null</pre>
</div>
</div>
</li>
<li>
<p>Read data from a child node</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> json = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
        {
            </span><span class="delimiter">&quot;</span></span>data<span class="string"><span class="delimiter">&quot;</span><span class="content"> : [
                { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:1, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S1<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
                { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:2, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S2<span class="string"><span class="delimiter">&quot;</span><span class="content"> },
                { </span><span class="delimiter">&quot;</span></span>a<span class="string"><span class="delimiter">&quot;</span><span class="content">:3, </span><span class="delimiter">&quot;</span></span>b<span class="string"><span class="delimiter">&quot;</span><span class="content">:</span><span class="delimiter">&quot;</span></span>S4<span class="string"><span class="delimiter">&quot;</span><span class="content"> }
            ]
        }</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

DataFrame df = Json
        .loader()
        .pathExpression(<span class="string"><span class="delimiter">&quot;</span><span class="content">$.data.*</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
        .nullsForMissingLeafs()
        .load(json);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This JSONPath query finds the <code>data</code> property of the root node and sets it as the root for the <code>DataFrame</code> data
extraction</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>a b
- --
1 S1
2 S2
3 S4</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_json_data_sources">JSON Data Sources</h4>
<div class="paragraph">
<p>Just like CSV, JSON data can be read from local files (<code>java.nio.file.Path</code> or <code>java.io.File</code>) as well as from
a <code>ByteSource</code> or <code>ByteSources</code>, such as URLs (see <a href="#bin_data_sources">"Binary Data Sources" chapter</a>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_json">Writing JSON</h3>
<div class="paragraph">
<p><code>JsonSaver</code> generates JSON from <code>DataFrames</code> in a "list-of-objects" format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame
        .byArrayRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>)
        .appender()
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joe</span><span class="delimiter">&quot;</span></span>, <span class="integer">18</span>)
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Andrus</span><span class="delimiter">&quot;</span></span>, <span class="integer">45</span>)
        .append(<span class="string"><span class="delimiter">&quot;</span><span class="content">Joan</span><span class="delimiter">&quot;</span></span>, <span class="integer">32</span>)
        .toDataFrame();

<span class="predefined-type">String</span> json = Json
        .saver()
        .saveToString(df); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This form of "save" produces a JSON String</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>[
    {"name":"Joe","age":18},
    {"name":"Andrus","age":45},
    {"name":"Joan","age":32}
]</pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can save JSON to a file or to an <code>Appendable</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bin_data_sources">Binary Data Sources</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two interfaces that allow format-specific DFLib loaders to access streams of bytes and produce <code>DataFrame</code>
instances. Those are <code>ByteSource</code>, a single binary resource and <code>ByteSources</code>, a collection of such resources. Most
loaders accept <code>ByteSource</code> (and sometimes, <code>ByteSources</code>) as an argument to their <code>load(..)</code>
method. E.g. loaders for CSV, Avro, Parquet, JSON support both <code>ByteSource</code> and <code>ByteSources</code>, Excel loader supports
<code>ByteSource</code>, and JDBC loader supports neither (because JDBC doesn&#8217;t expose ResultSets as byte streams).</p>
</div>
<div class="paragraph">
<p>DFLib provides a growing number of out-of-the-box <code>ByteSource</code> implementations as described below. And you can
implement your own if needed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ByteSources</code> doesn&#8217;t have any interesting implementations as of DFlib <code>1.x</code>, but in the future releases there will
be sources for ZIP archives, cloud folders, and such.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_byte_array_bytesource">Byte Array ByteSource</h3>
<div class="paragraph">
<p>The simplest ByteSource is a wrapper around a <code>byte[]</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">byte</span><span class="type">[]</span> bytes = <span class="comment">// ...</span>
ByteSource src = ByteSource.of(bytes);  <i class="conum" data-value="1"></i><b>(1)</b>

DataFrame df = Csv
        .loader()
        .load(src); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a <code>ByteSource</code> from a <code>byte[]</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>To make a <code>DataFrame</code>, use an appropriate loader matching the format of the data stored in the <code>byte[]</code></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_url_bytesource">URL ByteSource</h3>
<div class="paragraph">
<p>Lots of data exists on the web that can be accessed via URLs. There is a <code>ByteSource</code> for that. Of course the URL
must be publicly accessible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ByteSource src = ByteSource.ofUrl(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://example.org/my.csv</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, the JVM can expose application resources as URLs, and the same API can be used to create a <code>ByteSource</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ByteSource src = ByteSource.ofUrl(getClass().getResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">f1.csv</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_http_bytesource">HTTP ByteSource</h3>
<div class="paragraph">
<p>While the <code>ByteSource.ofUrl(..)</code> example above works well for simple public URLs, DFLib provides a more advanced HTTP connector to
access web resources. It allows to send authorization (or any other) headers  and also build URLs from parts incrementally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ByteSource src = Http.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://example.org/</span><span class="delimiter">&quot;</span></span>)
        .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">dir/my.csv</span><span class="delimiter">&quot;</span></span>)
        .queryParam(<span class="string"><span class="delimiter">&quot;</span><span class="content">ts</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">System</span>.currentTimeMillis())
        .header(<span class="string"><span class="delimiter">&quot;</span><span class="content">Authorization</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Bearer abcdefghijklmnop</span><span class="delimiter">&quot;</span></span>)
        .source();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Http</code> connector is immutable. Each builder method above produces an altered <em>copy</em> of the original connector. This
means you can reuse a partially built connector to produce multiple resource-specific connectors.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jshell">Using JShell</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modern JDK installations come with <code>jshell</code>, a Read-Evaluate-Print Loop tool (aka REPL). DFLib can be used in
JShell environment for interactive data exploration and code prototyping. For the best experience, you may want to
configure a couple of things. Start <code>jshell</code> and execute the following commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>// Set classpath.
// There's no automatic dependency management in jshell.
// You will need to include all DFLib jars and their
// dependencies explicitly

/env --class-path /path/to/dflib-2.0.0-M1.jar:/path/to/dflib-csv-2.0.0-M1.jar</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>// Disable data truncation. You want your data to be visible.

/set mode mine normal -command
/set truncation mine 40000
/set feedback mine</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>// Add needed imports

import org.dflib.*;
import org.dflib.csv.*;

import static org.dflib.Exp.*;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>// Set tabular printer

Environment.setPrinter(Printers.tabular());</code></pre>
</div>
</div>
<div class="paragraph">
<p>After this, you can start working with DataFrames and immediately check the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>var df = Csv.load(&quot;../data/stuff.csv&quot;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>JShell may print something like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre>df ==&gt;
id   name              salary
---- ----------------- --------
   1 Jerry Cosin       70000.0
   2 Juliana Walewski  85000.0
   3 Joan O'Hara       101000.0
...
 997 Jenny Harris      65000.0
 998 Matt Ostin        52000.0
 999 Andrew Tsui       99000.0
1000 rows x 3 columns</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jupyter">Using Jupyter Notebook</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While DFLib runs inside regular Java applications or <code>jshell</code>, it also works perfectly in Jupyter, which is a very
common "notebook" environment among data scientists and data engineers. In a notebook, you interact with your code via
a web browser in a rather visual way. It allows to run steps of a data transformation one-by-one and inspect the
data between the steps. Jupyter is often associated with Python / pandas, but it can also be used with Java / DFLib.</p>
</div>
<div class="paragraph">
<p>The code developed in a notebook can be later copied and pasted into your application. Java developers should consider
using either Jupyter as a part of their data project workflow, and DFLib design (and its Jupyter integration features
described here) makes it rather easy.</p>
</div>
<div class="paragraph">
<p>Java support for Jupyter is provided by <code>jjava</code> project that is also maintained by the DFLib community. Once you follow
the <a href="https://dflib.org/jjava/docs/1.x/#_installation">installation instructions</a> and then
<a href="https://dflib.org/jjava/docs/1.x/#_running_jupyter">run Jupyter</a>, you should end up with a browser window open with
Jupyter UI. Create a new notebook, and when asked to select a kernel, pick "Java". In the first cell enter something
like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">%maven org.dflib:dflib-jupyter:<span class="float">2.0</span><span class="float">.0</span>-M1 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding <code>dflib-jupyter</code> as a dependency also includes all  other DFLib modules through its transitive dependencies.
Also, it will load base DFLib imports, and configure Jupyter environment for pretty display of DataFrames and Series.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Click "Shift + Return" to execute the cell. If there are no errors, you can start using DFLib API in the following cells.
E.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByColumn(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)
    .ofInts(-<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>, <span class="integer">6</span>);

<span class="comment">// the result of the last statement in a cell is printed just below it</span>
df</code></pre>
</div>
</div>
<div class="paragraph">
<p>DFLib development is literally "visual" in Jupyter, as in addition to tabular data, you can display graphical
<a href="#echarts">charts</a> with contents of DataFrames:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/chart-in-jupyter.png" alt="chart in jupyter"></span></p>
</div>
<div class="sect2">
<h3 id="_change_display_parameters">Change Display Parameters</h3>
<div class="paragraph">
<p>To control truncation behavior, you can use static methods on <code>DFLibJupyter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DFLibJupyter.setMaxDisplayRows(<span class="integer">10</span>);
DFLibJupyter.setMaxDisplayColumnWidth(<span class="integer">50</span>);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="echarts">Charting with ECharts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DFLib provides a simple Java API to generate charts from DataFrames based on the <a href="https://echarts.apache.org">Apache ECharts library</a>.
Charts are produced as pieces of HTML/JavaScript code and can be rendered either in Jupyter notebooks or served to
the browser in a webapp.</p>
</div>
<div class="paragraph">
<p>The focus of this chapter is the DFLib API. We don&#8217;t dwell much on the underlying ECharts concepts, so you may need to read
their documentation to get explanations of things like multiple axes, grid, etc. The main difference of the DFLib
approach is that you don&#8217;t need to explicitly specify chart <code>dataset</code> or <code>data</code> sections. Instead, you&#8217;d define which
<code>DataFrame</code> columns should be used for chart series, axes, etc., and DFLib generates the data-related parts
from the provided <code>DataFrame</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The ECharts JavaScript API contains a very large number of chart types and configuration options. DFLib
<code>EChart</code> class supports a growing, but incomplete subset of that API. If we are missing a feature that you need,
please open a task on GitHub, and we&#8217;ll do our best to integrate it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To work with the ECharts API, you should include the following dependency (already included in the
<a href="#jupyter">Jupyter environment</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.dflib<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>dflib-echarts<span class="tag">&lt;/artifactId&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then you can create a chart. E.g., here is a simple bar chart showing employee salaries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DataFrame df = DataFrame.foldByRow(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).of(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">J. Cosin</span><span class="delimiter">&quot;</span></span>, <span class="integer">120000</span>,
                <span class="string"><span class="delimiter">&quot;</span><span class="content">J. Walewski</span><span class="delimiter">&quot;</span></span>, <span class="integer">80000</span>,
                <span class="string"><span class="delimiter">&quot;</span><span class="content">J. O'Hara</span><span class="delimiter">&quot;</span></span>, <span class="integer">95000</span>)
        .sort(<span class="error">$</span>col(<span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>).desc());

EChartHtml chart = ECharts
        .chart()
        .xAxis(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>)
        .series(SeriesOpts.ofBar(), <span class="string"><span class="delimiter">&quot;</span><span class="content">salary</span><span class="delimiter">&quot;</span></span>)
        .plot(df);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>EChartHtml</code> object contains pieces of HTML and JavaScript needed to render the following chart in the browser:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/doc-chart1.svg" alt="doc chart1"></span></p>
</div>
<div class="paragraph">
<p>Running this code in Jupyter will render the chart above in the browser. So you don&#8217;t need to do anything
special to display it. When embedding charts in web applications, you&#8217;ll need to inspect <code>EChartHtml.getContainer()</code>,
<code>EChartHtml.getExternalScript()</code>, <code>EChartHtml.getScript()</code> methods and insert them in your HTML as you see fit.</p>
</div>
<div class="sect2">
<h3 id="_line_charts">Line Charts</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_bar_charts">Bar Charts</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_scatter_charts">Scatter Charts</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_pie_charts">Pie Charts</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_candlestick_charts">Candlestick Charts</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unit-testing">Unit Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-02-03 11:36:15 -0500
</div>
</div>
<link media="all" rel="stylesheet" href="../../../css/style_v2.min.css" />
</body>
</html>