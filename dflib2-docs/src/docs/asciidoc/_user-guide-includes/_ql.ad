[#query_lang]
== Query Language

DFLib Query Language ("QL" for short) is a special syntax parsable by the library. It can be thought as a (rather small)
subset of SQL that simplifies querying, transforming and sorting DataFrames. At the high level, it takes one of these
forms:

```
<exp>                                     // parsed to a single Exp
<exp> [, <exp>]*                          // parsed to an Exp[]
<exp> [asc|desc]?                         // parsed to a single Sorter
<exp> [asc|desc]? [, <exp> [asc|desc]?]*  // parsed to a Sorter[]
```

So QL can produce these four objects - a single `Exp`, an `Exp[]`, a single `Sorter` or a `Sorter[]` and, as
mentioned previously, can be used interchangeably with them throughout DFLib. Expression parsing examples:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=parseExp]
----
<1> A single expression
<2> Two expressions separated by comma

Sorter parsing examples:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=parseSorter]
----

NOTE: Most DFLib APIs take QL strings and call `parse` internally. You may not need to parse QL in your code at all.
One possible exception is performance - parsing a piece of QL once and reusing `Exp` or `Sorter` object may save CPU
cycles in some cases.

Now let's discuss the QL syntax (i.e., what that `<exp>` above means). It consists of column references, literals,
parameters, operators and functions. We'll look at them individually...

=== Columns

NOTE: A commented-out code below each expression in the following examples is an equivalent expression created via the
Java API.

Expressions can reference `DataFrame` column names either by name or by position. If a column name is compatible with
Java identifier naming (and is not one of the QL keywords like `true`, `false`, `null`), it can be used as
an unquoted string:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=column]
----

If it has other characters (e.g. spaces, special chars, or starts with a number), it should be enclosed in backtick
quotes:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnBackticks]
----

If the name itself contains backticks, each one of them should be escaped with another backtick:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnBackticksEscape]
----

Columns can also be referred by their position in the `DataFrame` using the `col(..)` function:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnByIndex]
----

=== Literals
==== String Literals

Unlike columns, constant String values are always quoted using single quotes:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=strVal]
----

If a String contains single quotes, each one should be escaped with another single quote:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=strValEscape]
----

==== Numeric Literals
Numeric values are just unquoted numbers (mostly) following the Java syntax for decimals (and hexadecimals):
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=intVal]
----

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=intValNegative]
----

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=floatVal]
----

The expression parser tries to guess the type of the number automatically, but the user can control the type explicitly
by providing a 1-letter suffix following the numeric constant part:

* `i` - `int`
* `l` - `long`
* `h` - `BigInteger`
* `f` - `float`
* `d` - `double`
* `m` - `BigDecimal`

These suffixes are case-insensitive (both upper and lower cases are valid). Most have the same meaning as in Java
(`l`, `f`, `d`), but some are unique to DFLib, namely `i`, `h`, `m`:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=decimalVal]
----

==== Boolean Literals

Lowercase unquoted `true` and `false` strings are recognized as the corresponding boolean constants.

==== Null Literal

Lowercase unquoted `null` string is recognized as a null constant.

==== Parameters

A QL parameter (denoted by the `?` symbol) is a placeholder for a literal that is substituted with a real value during
QL parsing. Parameters are used for convenience to avoid string concatenation or for values that are not easy to
represent as strings. Parameters are positional and are substituted with an array of values:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=literalParam]
----

A special case is where a single collection parameter replaces a sequence of literals (notably, the right-hand
side of an `in` expression):

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=listParam]
----

=== Operators

Operators are used to build more complex expressions from columns and literals. The following operators are supported,
in the order of declining precedence:

* `(  )` - parenthesis has the highest precedence during evaluation
* `not`
* `*`, `/`, `%`
* `+`, `-`
* `<`, `>`, `\<=`, `>=`, `in`, `between .. and`
* `=`, `!=`
* `and`
* `or`
* `as`
* `asc`, `desc`

This order follows the rules of the Java language (where applicable) and should be intuitive to Java programmers.
If multiple operators have the same precedence, they are evaluated left to right.

==== Naming Operator

`as` operator assigns a name to an expression. The reason we care about names here is that expressions evaluate to
columns and names is a handy mechanism to label those columns in the resulting `DataFrame`. E.g.,
`as` expressions can be used for <<column_ops_rename,renaming columns>>. Here is a standalone example:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=as]
----

Without this operator, DFLib would auto-generate a name based on the expression semantics. E.g., the name in the example
above would've been something like `a * 5`. The identifier following `as` should adhere to the regular quoting rules
for special characters in column names. E.g.:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=asQuote]
----

==== Sort Direction Operators
When building a sorter, an expression can be followed by either `asc` or `desc` keyword to indicate ascending or
descending sort direction. If omitted, `asc` is implied.

=== Functions

All operations that are not one of the _operators_ above are implemented as _functions_ in the form of
`fname(arg1, arg2, ...)`. Arguments to functions can be column references, literals and other expressions.
The following functions come with DFLib out of the box:

==== Type-Setting Functions
These functions specify the type of another expression if it is not clear from the context. A specific type may be
required by other functions or operators. E.g.,

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=typeSetToLong]
----

Here, the `long(..)` function takes a column, but it can take any other expression as well. The function doesn't do
data transformation, so if during evaluation the values in column "a" are not `Long` or `long` (or null),
an exception is thrown. The available functions are:

=====  `bigint(exp)`
=====  `bool(exp)`
=====  `date(exp)`
=====  `dateTime(exp)`
=====  `decimal(exp)`
=====  `double(exp)`
=====  `float(exp)`
=====  `int(exp)`
=====  `long(exp)`
=====  `offsetDateTime(exp)`
=====  `str(exp)`
=====  `time(exp)`

NOTE: Our goal is to greatly reduce the need for explicit type setting, guessing the correct type from the
expression itself. This will be improving in the future to make it more seamless.

==== Type-Casting Functions
Type-casting functions closely mirror type-setting ones, but they would actually attempt to transform unknown column
data to the requested type:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=typeCastToLong]
----

NOTE: Some "cast" transformations may be inefficient, performed via an intermediate conversion to Strings. Others
may be outright invalid (e.g. `castAsInt('abc')`). In those cases, you won't be able to use the standard type-casting
functions and will need to provide your own transformations.

===== `castAsBigint(exp)`

=====  `castAsBool(exp)`
=====  `castAsDate(exp [, format_string])`
Converts expression argument to a `LocalDate`. If the expression produces
values are not ISO-8601 date strings, you should pass the second optional argument which is a String literal parse
specification compatible with Java `DateTimeFormatter`.

=====  `castAsDateTime(exp [, format_string])`
Converts expression argument to a `LocalDateTime`. If the expression
produces values that are not ISO-8601 date-time strings, you should pass the second optional argument which is a
String literal parse specification compatible with Java `DateTimeFormatter`.

=====  `castAsDecimal(exp)`
=====  `castAsDouble(exp)`
=====  `castAsFloat(exp)`
=====  `castAsInt(exp)`
=====  `castAsLong(exp)`

=====  `castAsOffsetDateTime(exp [, format_str])`
Converts expression argument to a `OffsetDateTime`. If the expression produces values that are not ISO-8601 offset
datetime strings, you should pass the second optional argument which is a String literal parse specification compatible
with Java `DateTimeFormatter`.

=====  `castAsStr(exp)`
Applies a `toString()` conversion to each element of the result of the `exp` argument.

=====  `castAsTime(exp [, format_str])`
Converts expression argument to a `LocalTime`. If the expression produces values that are not ISO-8601 time strings,
you should pass the second optional argument which is a String literal parse specification compatible with Java
`DateTimeFormatter`.

==== String Functions

=====  `concat(exp_or_literal [, exp_or_literal ...]])`

Takes any number of arguments that are either expressions or literals (that are internally expanded to Series), producing
a Series where each element is a result of String concatenation of elements at the same position taken from each
argument Series.

=====  `contains(exp, substring_str)`
=====  `endsWith(exp, substring_str)`
=====  `len(exp)`
=====  `lower(exp)`
=====  `matches(exp, regex_str)`
=====  `split(exp, delimiter_str [, limit_int])`
=====  `startsWith(exp, substring_str)`
=====  `substr(exp, from_int [, len_int])`
=====  `trim(exp)`
=====  `upper(exp)`

==== Numeric Functions

Many scalar numeric operations are implemented as operators (described above). Here are the ones that are done as
functions:

=====  `abs(exp)`
=====  `cumSum(exp)`
=====  `round(exp)`

==== Date Functions

===== `day(exp)`
===== `month(exp)`
===== `year(exp)`

===== `plusDays(exp, days_int)`
===== `plusMonths(exp, months_int)`
===== `plusWeeks(exp, weeks_int)`
===== `plusYears(exp, years_int)`

==== Date-Time Functions

===== `day(exp)`
===== `hour(exp)`
===== `millisecond(exp)`
===== `minute(exp)`
===== `month(exp)`
===== `second(exp)`
===== `year(exp)`

===== `plusDays(exp, days_int)`
===== `plusHours(exp, hours_int)`
===== `plusMillisecond(exp, ms_int)`
===== `plusMinutes(exp, min_int)`
===== `plusMonths(exp, months_int)`
===== `plusNanos(exp, nanos_int)`
===== `plusSeconds(exp, sec_int)`
===== `plusWeeks(exp, weeks_int)`
===== `plusYears(exp, years_int)`

==== Offset Date-Time Functions

===== `day(exp)`
===== `hour(exp)`
===== `millisecond(exp)`
===== `minute(exp)`
===== `month(exp)`
===== `offset(exp)`
===== `second(exp)`
===== `year(exp)`

===== `plusDays(exp, days_int)`
===== `plusHours(exp, hours_int)`
===== `plusMillisecond(exp, ms_int)`
===== `plusMinutes(exp, min_int)`
===== `plusMonths(exp, months_int)`
===== `plusNanos(exp, nanos_int)`
===== `plusSeconds(exp, sec_int)`
===== `plusWeeks(exp, weeks_int)`
===== `plusYears(exp, years_int)`

==== Time Functions

===== `hour(exp)`
===== `millisecond(exp)`
===== `minute(exp)`
===== `second(exp)`

===== `plusHours(exp, hours_int)`
===== `plusMillisecond(exp, ms_int)`
===== `plusMinutes(exp, min_int)`
===== `plusNanos(exp, nanos_int)`
===== `plusSeconds(exp, sec_int)`

==== Conditional Functions

=====  `if(condition, if_true_exp, if_false_exp)`
Picks values from either of the two series produced by `if_true_exp` or `if_false_exp` based on the condition at a
given position. First evaluates the `condition` to a Series of booleans, and then assembles the result with all `true`
positions taken from `if_true_exp`, and all `false` - from `if_false_exp`.

=====  `ifNull(exp, if_null_exp)`
A special form of `if` where the condition is a null check. Assembles the result with all not-null `exp` values
included, and the null values substituted with the result of `if_null_exp` at a matching position.

==== Other Functions
=====  `rowNum()`
=====  `shift(exp, offset_int [, filler_literal])`

==== Aggregating Functions

Aggregating functions usually take an expression argument that evaluates to a `Series` and then _aggregate_ it somehow
producing a single value. (`count()` function is slightly different. It doesn't take an expression, but the idea is the
same - it counts the rows in the input DataFrame).

===== `array(exp)`
Applied to the Series returned from evaluating the `exp` argument. Returns an array containing all series values.

===== `avg(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Calculates and returns the average value
of a series. `exp` must be a numeric or one of the date & time expressions. If an optional `condition` is passed, will
return the average among the values matching the condition.

===== `count([condition])`
The default no-argument flavor returns the number of rows in the aggregated series. If a conditional expression
is passed as an argument, only counts the rows matching the condition.

===== `first(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. The default single-argument flavor returns
the first element in the series. If an optional `condition` is passed, returns the first value matching the
condition.

===== `last(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. The default single-argument flavor returns
the last element in the series. If an optional `condition` is passed, returns the last value matching the
condition.

===== `list(exp)`
Applied to the Series returned from evaluating the `exp` argument. Returns a `List` containing all series values.

===== `max(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Returns the maximum value in the series. `exp`
must be a string, numeric or one of the date & time expressions. If an optional `condition` is passed, returns the
maximum among values matching the condition.

===== `median(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Calculates and returns the median value
of a series. `exp` must be a numeric or one of the date & time expressions. If an optional `condition` is passed,
returns the median among values matching the condition.

===== `min(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Returns the minimum value in the series. `exp`
must be a string, numeric or one of the date & time expressions. If an optional `condition` is passed, returns
the minimum among
values matching the condition.

===== `quantile(exp, quantile_double [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Calculates and returns the specified
quantile value of a series. `exp` must be numeric or one of the date & time expressions. If an optional `condition` is passed, will
return the quantile among those matching the condition.

===== `set(exp)`
Applied to the Series returned from evaluating the `exp` argument. Returns a `Set` containing all series values.

===== `stdDev(exp [, use_population_bool])`
Applied to the Series returned from evaluating the `exp` argument. Returns the standard deviation of the series. `exp`
must be a numeric expression. An optional `use_population_bool` argument allows to specify whether to use "population"
(`true`) or "sample" (`false`) standard deviation. If omitted, "population" is assumed.

===== `sum(exp [, condition])`
Applied to the Series returned from evaluating the `exp` argument. Returns the sum of the series values. `exp`
must be a numeric expression. If an optional `condition` is passed, returns the sum among the values matching the condition.

===== `variance(exp [, use_population_bool])`
Applied to the Series returned from evaluating the `exp` argument. Returns the variance of the series. `exp`
must be a numeric expression. An optional `use_population_bool` argument allows to specify whether to use "population"
(`true`) or "sample" (`false`) variance. If omitted, "population" is assumed.

===== `vConcat(exp [, condition], delimiter_str [, prefix_str, suffix_str])`
Applied to the Series returned from evaluating the `exp` argument. Returns a String that is concatenation of
the series values separated by `delimiter_str`. Optionally takes a condition, so only the matching values are concatenated.
Optionally takes `prefix_str` and `suffix_str` for concatenation prefix and suffix.

NOTE: Unlike `concat(..)`, this is a "vertical" concatenation operation that produces a String from a single Series instead of
a Series of Strings from multiple Series.