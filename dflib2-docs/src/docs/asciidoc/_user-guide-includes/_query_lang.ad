[#query_lang]
== Query Language

DFLib Query Language (QL for short) is a special syntax parsable by the library into expressions or sorters. It can be
thought as a (rather small) subset of SQL that simplifies querying DataFrames. QL strings can be parsed into one of four
Java objects - an `Exp`, an `Exp[]`, a `Sorter` or a `Sorter[]`. Expression parsing examples:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=parseExp]
----
<1> A single expression
<2> Two expressions separated by comma

Sorter parsing examples:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=parseSorter]
----

NOTE: As shown in the following chapters, most DFLib APIs take QL strings directly calling `Exp.parse*` and
`Sorter.parse*` internally. You'd rarely need to explicitly parse them in your code.

We'll discuss QL syntax next. It consists of column references, literals (including parameters - a special kind of
literals), operators and functions. Let's look at them individually...

NOTE: A commented-out String below each expression in the following examples is an equivalent created via the Java API.

=== Columns

Expressions can reference `DataFrame` column names either by name or by position. If a column name is compatible with
the rules for Java identifiers (and doesn't conflict with syntax keywords like `true`, `false`, `null`), the column can
be specified as an unquoted string:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=column]
----

If it has other characters (e.g. spaces, special chars, or it starts with a number), it should be enclosed in backtick
quotes:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnBackticks]
----

If the name itself contains backticks, each one of them should be escaped with another backtick:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnBackticksEscape]
----

Columns can also be referred by their position in the `DataFrame` using the `col(..)` function:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=columnByIndex]
----

=== Literals
==== String Literals

Unlike columns, constant String values are always quoted using single quotes:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=strVal]
----

If a String contains single quotes, each one should be escaped with another single quote:
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=strValEscape]
----

==== Numeric Literals
Numeric values are just unquoted numbers (mostly) following the Java syntax for decimals (and hexadecimals):
[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=intVal]
----

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=intValNegative]
----

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=floatVal]
----

The expression parser tries to guess the type of the number automatically, but the user can control the type explicitly
by providing a 1-letter suffix following the numeric constant part:

* `i` - parses the number as an `int`
* `l` - parses the number as a `long`
* `h` - parses the number as a `BigInteger`
* `f` - parses the number as a `float`
* `d` - parses the number as a `double`
* `m` - parses the number as a `BigDecimal`

These codes are case-insensitive (both upper and lower cases are valid). Most have the same meaning as in Java
(`l`, `f`, `d`), but some are unique to DFLib, namely `i`, `h`, `m`:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=decimalVal]
----

==== Boolean Literals

Lowercase unquoted `true` and `false` strings are recognized as the corresponding boolean constants.

==== Null literal

Lowercase unquoted `null` string is recognized as a null constant.

==== Parameters

A QL parameter (denoted by the `?` symbol) is a placeholder for a literal that is substituted with a real value during
QL parsing. Parameters are used for convenience to avoid string concatenation or to represent values that are not easy to
represent as strings to begin with. Parameters are positional and are substituted using an array of values:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=literalParam]
----

A special case is when a single collection parameter can replace multiple literals (notably the `in` expression):

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=listParam]
----

=== Operators

The following operators are supported, in the order of declining precedence:

* `(  )` - parenthesis has the highest precedence during evaluation
* `not`
* `*`, `/`, `%`
* `+`, `-`
* `<`, `>`, `\<=`, `>=`
* `=`, `!=`, `in`
* `and`
* `or`
* `as`
* `asc`, `desc`

This order follows the rules of the Java language (where applicable) and should be intuitive to Java programmers.
If multiple operators have the same precedence, they will be evaluated left to right.

==== Column Naming Operator

...

==== Sort Direction Operators

When building a sorter, an expression can be followed by either `asc` or `desc` keyword to indicate ascending or
descending sort direction. If omitted, `asc` is implied.

=== Functions
All operations that are not on the operator list above are implemented as functions in the form of `fname(arg1,arg2,...)`.
Arguments to functions can be other expressions (including column references and literals). Out-of-the-box, the following
functions are supported:

==== Type-Setting Functions
These functions specify the type of another expression if it is not clear from the context. A specific type may be
required by the expression grammar to figure out how to perform certain operations. E.g.,

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=typeSetToLong]
----

Here, the `long(..)` function takes a column, but it can take any other expression as well. The function doesn't do
data transformation, so if during evaluation the values in column "a" are not `Long` or `long` (or null),
an exception will be thrown. The available functions are:

* `bigint(..)`
* `bool(..)`
* `date(..)`
* `dateTime(..)`
* `decimal(..)`
* `double(..)`
* `float(..)`
* `int(..)`
* `long(..)`
* `offsetDateTime(..)`
* `str(..)`

NOTE: Our goal is to greatly reduce the need for explicit type-setting functions, guessing the correct type from the
expression itself. This area will be improving in the future releases.

==== Type-Casting Functions
Type-casting functions are similar to type-setting, but they would actually attempt to transform unknown column data
to the requested type:

[source,java,indent=0]
----
include::../../../test/java/org/dflib/docs/QLTest.java[tags=typeCastToLong]
----
They closely mirror the type-setting functions:

* `castAsBigint(..)`
* `castAsBool(..)`
* `castAsDate(..)`
* `castAsDateTime(..)`
* `castAsDecimal(..)`
* `castAsDouble(..)`
* `castAsFloat(..)`
* `castAsInt(..)`
* `castAsLong(..)`
* `castAsOffsetDateTime(..)`
* `castAsStr(..)`

NOTE: Some "cast" transformations may be inefficient, performed via an intermediate conversion to Strings. Others
may be outright invalid (e.g. `castAsInt('abc')`). In those cases, you will need to provide your own explicit
columnset transforming operation.

==== String Functions
* `concat(..)`
* `endsWith(..)`
* `matches(..)`
* `split(..)`
* `startsWith(..)`
* `substr(..)`
* `trim(..)`

==== Numeric Functions
...

==== Date and Time Functions
...

==== Inline Conditions
* `if(..)`
* `ifNull(..)`

==== Other Functions
* `rowNum()`
* `shift(..)`

==== Aggregating Functions
...
